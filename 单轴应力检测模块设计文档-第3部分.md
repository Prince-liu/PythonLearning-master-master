# 单轴应力检测模块设计文档 v1.0 - 第3部分

> **包含章节**：第7章 实时云图算法、第8章 数据结构、第9章 API接口设计、第10章 实现计划  
> **上一部分**：[第2部分](./单轴应力检测模块设计文档-第2部分.md)  
> **返回首页**：[第1部分](./单轴应力检测模块设计文档.md)

---

## 7. 实时云图算法

### 7.1 渐进式插值策略

#### 阶段划分
```python
def get_interpolation_strategy(n_measured):
    """根据已测点数选择插值策略"""
    if n_measured < 3:
        return 'points_only'  # 只显示离散点
    elif n_measured < 9:
        return 'linear'       # 线性插值 + 警告
    else:
        return 'cubic'        # 三次插值
```

#### 实时更新逻辑
```python
async def update_contour_realtime(new_point_data):
    """实时更新云图"""
    # 1. 添加新测点数据
    measured_points.append(new_point_data)
    
    # 2. 判断插值策略
    strategy = get_interpolation_strategy(len(measured_points))
    
    if strategy == 'points_only':
        # 只绘制离散点
        draw_discrete_points(measured_points)
        show_message("数据点不足，暂不生成云图")
        
    elif strategy == 'linear':
        # 线性插值 + 警告
        contour_data = interpolate_linear(measured_points)
        draw_contour(contour_data, alpha=0.7)  # 半透明
        show_warning("数据点较少，云图仅供参考")
        
    else:
        # 完整三次插值
        contour_data = interpolate_cubic(measured_points)
        draw_contour(contour_data, alpha=1.0)
```

### 7.2 插值算法实现

#### 核心代码
```python
from scipy.interpolate import griddata
import numpy as np

def interpolate_stress_field(points, shape_config, resolution=100):
    """插值生成应力场"""
    # 1. 提取坐标和应力值
    coords = np.array([[p['x'], p['y']] for p in points])
    stress = np.array([p['stress'] for p in points])
    
    # 2. 生成密集网格
    x_min, x_max = 0, shape_config['width']
    y_min, y_max = 0, shape_config['height']
    
    xi = np.linspace(x_min, x_max, resolution)
    yi = np.linspace(y_min, y_max, resolution)
    xi, yi = np.meshgrid(xi, yi)
    
    # 3. 插值计算
    method = 'cubic' if len(points) >= 9 else 'linear'
    zi = griddata(coords, stress, (xi, yi), method=method)
    
    # 4. 遮罩无效区域（孔洞、边界外）
    mask = create_shape_mask(xi, yi, shape_config)
    zi = np.ma.masked_where(~mask, zi)
    
    return xi, yi, zi
```

#### 形状遮罩
```python
def create_shape_mask(xi, yi, shape_config):
    """创建形状遮罩"""
    from shapely.geometry import Point, Polygon
    
    # 创建形状对象
    if shape_config['type'] == 'rectangle':
        shape = create_rectangle_shape(shape_config)
    elif shape_config['type'] == 'circle':
        shape = create_circle_shape(shape_config)
    else:
        shape = Polygon(shape_config['vertices'])
    
    # 应用布尔运算（减去孔洞）
    for modifier in shape_config['modifiers']:
        if modifier['op'] == 'subtract':
            hole = create_hole_shape(modifier)
            shape = shape.difference(hole)
    
    # 生成遮罩
    mask = np.zeros_like(xi, dtype=bool)
    for i in range(xi.shape[0]):
        for j in range(xi.shape[1]):
            point = Point(xi[i,j], yi[i,j])
            mask[i,j] = shape.contains(point)
    
    return mask
```

### 7.3 性能优化

#### 增量更新
```python
class ContourCache:
    """云图缓存，支持增量更新"""
    def __init__(self):
        self.last_grid = None
        self.last_points = []
    
    def update(self, new_point):
        """增量更新云图"""
        # 只重新插值受影响的区域
        affected_region = self.get_affected_region(new_point)
        self.update_region(affected_region, new_point)
```

#### 分辨率自适应
```python
def get_adaptive_resolution(n_points, stage):
    """根据测点数和阶段选择分辨率"""
    if stage == 'measuring':
        # 采集阶段：低分辨率，快速更新
        return min(50, n_points * 5)
    else:
        # 分析阶段：高分辨率，精细显示
        return 200
```

### 7.4 视觉效果

#### 颜色映射
```python
import matplotlib.cm as cm

def apply_colormap(stress_data, vmin=None, vmax=None, cmap='rainbow'):
    """应用颜色映射"""
    if vmin is None:
        vmin = np.nanmin(stress_data)
    if vmax is None:
        vmax = np.nanmax(stress_data)
    
    # 归一化
    norm = (stress_data - vmin) / (vmax - vmin)
    
    # 应用色图
    colormap = cm.get_cmap(cmap)
    rgba = colormap(norm)
    
    return rgba
```

#### 等值线叠加
```python
def draw_contour_with_isolines(xi, yi, zi, levels=10):
    """绘制云图 + 等值线"""
    # 填充云图
    contourf(xi, yi, zi, levels=100, cmap='rainbow')
    
    # 叠加等值线
    contour(xi, yi, zi, levels=levels, colors='black', 
            linewidths=0.5, alpha=0.5)
    
    # 标注等值线数值
    clabel(contour_lines, inline=True, fontsize=8)
```

#### 测点标记
```python
def draw_point_markers(points, current_point_id=None):
    """绘制测点标记"""
    for point in points:
        if point['status'] == 'measured':
            color = 'green'
            marker = '●'
        elif point['id'] == current_point_id:
            color = 'yellow'
            marker = '◉'  # 高亮当前点
        else:
            color = 'gray'
            marker = '○'
        
        draw_marker(point['x'], point['y'], marker, color)
        draw_text(point['x'], point['y'], f"#{point['id']}")
```

---

## 8. 数据结构

### 8.1 数据库表设计（SQLite）

#### 表1：field_experiments（应力场实验）
```sql
CREATE TABLE field_experiments (
    id TEXT PRIMARY KEY,              -- 实验ID，如 "FIELD001"
    name TEXT NOT NULL,               -- 实验名称
    calibration_exp_id TEXT NOT NULL, -- 关联的标定实验ID
    calibration_direction TEXT,       -- 标定方向（如 "0°"）
    shape_config TEXT NOT NULL,       -- 形状配置（JSON）
    point_layout TEXT NOT NULL,       -- 测点布局（JSON）
    baseline_point_id INTEGER,        -- 基准测点ID
    baseline_stress REAL,             -- 基准应力值（可选）
    status TEXT DEFAULT 'planning',   -- 实验状态
    created_at TEXT,                  -- 创建时间
    completed_at TEXT,                -- 完成时间
    notes TEXT                        -- 备注
);
```

#### 表2：field_points（测点数据）
```sql
CREATE TABLE field_points (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    experiment_id TEXT NOT NULL,      -- 所属实验ID
    point_index INTEGER NOT NULL,     -- 测点编号
    x_coord REAL NOT NULL,            -- X坐标 (mm)
    y_coord REAL NOT NULL,            -- Y坐标 (mm)
    time_diff REAL,                   -- 声时差 (ns)
    stress_value REAL,                -- 应力值 (MPa)
    status TEXT DEFAULT 'pending',    -- 测点状态
    measured_at TEXT,                 -- 测量时间
    waveform_file TEXT,               -- HDF5文件路径
    quality_score REAL,               -- 信号质量评分
    is_suspicious BOOLEAN DEFAULT 0,  -- 是否可疑数据
    FOREIGN KEY (experiment_id) REFERENCES field_experiments(id)
);

CREATE INDEX idx_field_points_exp ON field_points(experiment_id);
```

#### 表3：field_metadata（云图元数据）
```sql
CREATE TABLE field_metadata (
    experiment_id TEXT PRIMARY KEY,
    interpolation_method TEXT,        -- 插值方法
    grid_resolution INTEGER,          -- 网格分辨率
    colormap TEXT,                    -- 色图名称
    vmin REAL,                        -- 色标最小值
    vmax REAL,                        -- 色标最大值
    contour_image_path TEXT,          -- 云图图片路径
    statistics TEXT,                  -- 统计信息（JSON）
    FOREIGN KEY (experiment_id) REFERENCES field_experiments(id)
);
```

### 8.2 HDF5 文件组织

#### 文件结构
```
data/waveforms/FIELD001/
├── metadata.json              # 实验元数据
├── shape_config.json          # 形状配置
├── point_layout.json          # 测点布局
├── point_001.h5               # 测点1波形
├── point_002.h5               # 测点2波形
├── ...
├── point_025.h5               # 测点25波形
└── contour_result.h5          # 云图结果数据
```

#### 单个测点HDF5结构
```python
# point_001.h5
{
    'waveform': {
        'time': [array],      # 时间轴
        'voltage': [array],   # 电压值
        'sample_rate': float  # 采样率
    },
    'metadata': {
        'point_id': 1,
        'x_coord': 10.0,
        'y_coord': 10.0,
        'measured_at': '2025-12-19 14:30:15',
        'scope_settings': {...}
    },
    'analysis': {
        'time_diff': 45.23,
        'stress': 120.5,
        'snr': 25.3,
        'quality_score': 0.95
    }
}
```

#### 云图结果HDF5结构
```python
# contour_result.h5
{
    'grid': {
        'xi': [2D array],     # X网格
        'yi': [2D array],     # Y网格
        'zi': [2D array]      # 应力值网格
    },
    'points': {
        'coords': [N×2 array],   # 测点坐标
        'stress': [N array]      # 测点应力值
    },
    'metadata': {
        'interpolation_method': 'cubic',
        'resolution': 200,
        'n_points': 25,
        'timestamp': '2025-12-19 15:45:30'
    }
}
```

### 8.3 前端数据格式

#### 形状配置对象
```javascript
const shapeConfig = {
    type: 'rectangle',  // 'rectangle' | 'circle' | 'polygon'
    
    // 矩形参数
    width: 100,
    height: 150,
    
    // 圆形参数
    centerX: 50,
    centerY: 50,
    outerRadius: 40,
    innerRadius: 0,
    startAngle: 0,
    endAngle: 360,
    
    // 多边形参数
    vertices: [[0,0], [100,0], [100,100], [0,100]],
    
    // 布尔运算
    modifiers: [
        {
            op: 'subtract',  // 'subtract' | 'add'
            shape: 'circle',
            centerX: 50,
            centerY: 75,
            radius: 20
        }
    ]
};
```

#### 测点数据对象
```javascript
const pointData = {
    id: 1,
    x: 10.0,
    y: 10.0,
    timeDiff: 45.23,
    stress: 120.5,
    status: 'measured',  // 'pending' | 'measuring' | 'measured' | 'skipped' | 'error'
    measuredAt: '2025-12-19 14:30:15',
    qualityScore: 0.95,
    isSuspicious: false
};
```

#### 云图数据对象
```javascript
const contourData = {
    grid: {
        xi: [[...]],  // 2D array
        yi: [[...]],
        zi: [[...]]   // 应力值
    },
    points: [
        {id: 1, x: 10, y: 10, stress: 120.5},
        // ...
    ],
    metadata: {
        method: 'cubic',
        resolution: 200,
        vmin: 0,
        vmax: 200,
        confidence: 'full'  // 'preview' | 'full'
    }
};
```

---

## 9. API 接口设计

### 9.1 后端 API（Python）

#### 实验管理
```python
class StressDetectionUniaxial:
    """应力检测模块 API"""
    
    def create_field_experiment(self, name, calibration_exp_id, 
                               calibration_direction, shape_config):
        """创建应力场实验"""
        return {
            "success": True,
            "data": {
                "experiment_id": "FIELD001",
                "name": name,
                "created_at": "2025-12-19 14:30:00"
            }
        }
    
    def load_field_experiment(self, experiment_id):
        """加载实验"""
        return {
            "success": True,
            "data": {
                "experiment_id": experiment_id,
                "name": "平板应力分布测试",
                "shape_config": {...},
                "point_layout": [...],
                "measured_points": [...]
            }
        }
    
    def delete_field_experiment(self, experiment_id):
        """删除实验"""
        return {"success": True, "message": "实验已删除"}
```

#### 形状和布点
```python
    def validate_shape(self, shape_config):
        """验证形状配置"""
        return {
            "success": True,
            "data": {
                "is_valid": True,
                "area": 15000.0,
                "warnings": []
            }
        }
    
    def generate_point_layout(self, shape_config, layout_type, params):
        """生成测点布局"""
        return {
            "success": True,
            "data": {
                "points": [
                    {"id": 1, "x": 10.0, "y": 10.0},
                    {"id": 2, "x": 30.0, "y": 10.0},
                    # ...
                ],
                "total_count": 25,
                "valid_count": 23
            }
        }
    
    def optimize_point_order(self, points, strategy='zigzag'):
        """优化测点顺序"""
        return {
            "success": True,
            "data": {
                "optimized_points": [...],
                "total_distance": 450.5
            }
        }
```

#### 数据采集
```python
    def capture_field_point(self, experiment_id, point_id):
        """采集单个测点"""
        return {
            "success": True,
            "data": {
                "point_id": point_id,
                "time_diff": 45.23,
                "stress": 120.5,
                "quality_score": 0.95
            }
        }
    
    def skip_field_point(self, experiment_id, point_id):
        """跳过测点"""
        return {"success": True, "message": f"测点 #{point_id} 已跳过"}
    
    def retry_field_point(self, experiment_id, point_id):
        """重测测点"""
        return {
            "success": True,
            "data": {
                "point_id": point_id,
                "time_diff": 46.12,
                "stress": 125.3
            }
        }
```

#### 云图生成
```python
    def update_field_contour(self, experiment_id):
        """更新云图"""
        return {
            "success": True,
            "data": {
                "mode": "contour",  # 'points_only' | 'contour'
                "grid": {
                    "xi": [[...]],
                    "yi": [[...]],
                    "zi": [[...]]
                },
                "method": "cubic",
                "confidence": "full"
            }
        }
    
    def export_field_contour_image(self, experiment_id, format='png'):
        """导出云图图片"""
        return {
            "success": True,
            "data": {
                "file_path": "data/exports/field_001.png"
            }
        }
    
    def export_field_data(self, experiment_id, format='csv'):
        """导出数据"""
        return {
            "success": True,
            "data": {
                "file_path": "data/exports/field_001_data.csv"
            }
        }
```

#### 统计分析
```python
    def get_field_statistics(self, experiment_id):
        """获取统计信息"""
        return {
            "success": True,
            "data": {
                "n_measured": 23,
                "n_total": 25,
                "max_stress": 158.7,
                "max_stress_point": 3,
                "min_stress": 0.0,
                "min_stress_point": 1,
                "mean_stress": 78.3,
                "std_stress": 42.1
            }
        }
```

### 9.2 前端调用示例

#### 创建实验
```javascript
async function createFieldExperiment() {
    const result = await pywebview.api.create_field_experiment(
        "平板应力分布测试",
        "EXP003",
        "0°",
        shapeConfig
    );
    
    if (result.success) {
        experimentId = result.data.experiment_id;
        console.log("实验创建成功:", experimentId);
    }
}
```

#### 生成测点
```javascript
async function generatePoints() {
    const result = await pywebview.api.generate_point_layout(
        shapeConfig,
        'grid',
        {rows: 5, cols: 5, margin: 10}
    );
    
    if (result.success) {
        points = result.data.points;
        drawPointsPreview(points);
    }
}
```

#### 采集循环
```javascript
async function startCapture() {
    for (const point of points) {
        if (point.status === 'pending') {
            // 提示用户
            showMessage(`请移动探头到测点 #${point.id} (${point.x}, ${point.y})`);
            
            // 采集
            const result = await pywebview.api.capture_field_point(experimentId, point.id);
            
            if (result.success) {
                // 更新数据
                point.stress = result.data.stress;
                point.status = 'measured';
                updateTable(point);
                
                // 更新云图
                await updateContour();
            }
        }
    }
}
```

#### 实时云图更新
```javascript
async function updateContour() {
    const result = await pywebview.api.update_field_contour(experimentId);
    
    if (result.success) {
        if (result.data.mode === 'contour') {
            ContourDrawing.drawContourMap(canvas, result.data.grid, shapeConfig);
            
            if (result.data.confidence === 'preview') {
                showWarning('数据点较少，云图仅供参考');
            }
        } else {
            drawDiscretePoints(points);
        }
    }
}
```

---

## 10. 实现计划

### 10.1 MVP 版本（第一版）

#### 核心功能
- ✅ 矩形试件形状定义
- ✅ 网格布点（均匀间距）
- ✅ 手动逐点采集
- ✅ 基础云图显示（cubic插值）
- ✅ 数据表格显示
- ✅ CSV 导出

#### 技术实现
```
后端模块:
  modules/stress_detection_uniaxial/
    ├── __init__.py
    ├── stress_detection_uniaxial.py  (扩展现有)
    ├── shape_utils.py                (新增)
    ├── point_generator.py            (新增)
    └── interpolation.py              (新增)

前端模块:
  static/js/stress-detection-uniaxial/
    ├── stress-detection-uniaxial.js  (重构)
    ├── single-point.js               (拆分)
    ├── field-mapping.js              (新增)
    └── contour-drawing.js            (新增)

样式:
  static/css/stress-detection.css
```

#### 数据库
```sql
-- 新增三个表
CREATE TABLE field_experiments (...);
CREATE TABLE field_points (...);
CREATE TABLE field_metadata (...);
```

#### 开发时间估算
- 后端 API：2-3天
- 前端 UI：3-4天
- 云图算法：2天
- 测试调试：2天
- **总计：9-11天**

### 10.2 第二版功能

#### 新增功能
- ✅ 圆形试件支持
- ✅ 布尔运算（孔洞/缺口）
- ✅ 极坐标布点
- ✅ 变间距布点
- ✅ 网格布点支持分别设置四边边距
- ✅ 绝对应力模式（支持输入基准点应力值）
- ✅ 实时云图更新（采集过程中）
- ✅ 测点顺序优化
- ✅ 自动采集模式
- ✅ 异常检测和重测
- ✅ 等值线显示
- ✅ Excel 导出
- ✅ 预览画布网格显示（自适应间距 + 刻度标注）

#### 技术增强
```python
# 新增依赖
requirements.txt:
  shapely>=2.0.0      # 几何运算
  openpyxl>=3.0.0     # Excel导出
```

#### 网格显示功能详细设计

**功能描述**：
在预览画布上显示自适应网格线和刻度标注，帮助用户更准确地定位和验证测点位置。

**自动间距算法**：
```javascript
function calculateGridSpacing(width, height) {
    /**
     * 自动计算合适的网格间距
     * 目标：画布上显示8-12条网格线
     */
    const maxDimension = Math.max(width, height);
    
    // 计算原始间距
    const rawSpacing = maxDimension / 10;
    
    // 取整到10的倍数（1, 10, 100, 1000...）
    const magnitude = Math.pow(10, Math.floor(Math.log10(rawSpacing)));
    
    // 选择最接近的标准间距（1x, 2x, 5x）
    if (rawSpacing / magnitude < 2) {
        return magnitude;
    } else if (rawSpacing / magnitude < 5) {
        return magnitude * 2;
    } else {
        return magnitude * 5;
    }
}
```

**示例效果**：
- 100×150mm试件 → 网格间距10mm
- 500×800mm试件 → 网格间距100mm
- 2000×3000mm试件 → 网格间距500mm
- 10000×15000mm试件 → 网格间距1000mm（1m）

**界面控制**：
```
预览画布右上角:
  ☑ 显示网格  密度: [○粗 ●中 ○细]
```

**密度选项**：
- 粗：间距 × 2（适合大样件快速预览）
- 中：自动计算（默认）
- 细：间距 ÷ 2（适合精确定位）

**绘制内容**：
1. 主网格线（灰色实线）
2. 次网格线（浅灰色虚线，间距÷5）
3. X轴刻度标注（底部）
4. Y轴刻度标注（左侧）
5. 原点标记（0, 0）

**增强功能**（可选）：
- 鼠标悬停显示坐标十字线
- 实时显示鼠标位置坐标
- 吸附到网格点功能（手动布点时）

#### 边距分别设置功能详细设计

**功能描述**：
支持为网格布点的四个边分别设置不同的边距值，适应局部区域测试和特殊约束场景。

**界面设计**：

**MVP版本**（统一边距）：
```
边距 (mm): [10]
```

**增强版本**（分别设置）：
```
边距 (mm): [10] [分别设置]
```

点击"[分别设置]"后展开：
```
边距设置:
  ○ 统一边距: [10] mm
  ● 分别设置:
    上边距: [5] mm
    下边距: [15] mm
    左边距: [10] mm
    右边距: [20] mm
    
  [应用] [恢复统一]
```

**应用场景**：
1. **夹具遮挡**：试件某一侧有夹具，需要更大边距避开
2. **局部测试**：只测试试件的特定区域（如中心区域）
3. **边缘损伤**：某侧边缘有损伤或缺陷，需要避开
4. **不对称试件**：试件本身形状不对称，需要不同边距

**示例效果**：

**统一边距10mm**（100×150mm试件）：
```
150mm ┌─────────────────────────┐
      │ ← 10mm                  │
      │   ●   ●   ●   ●   ●     │
      │   ●   ●   ●   ●   ●     │
      │                  10mm → │
  0mm └─────────────────────────┘
     0mm                    100mm
     
测试区域: X轴 10-90mm, Y轴 10-140mm
```

**分别设置**（上5/下15/左10/右20）：
```
150mm ┌─────────────────────────┐
      │ ← 5mm                   │
      │     ●   ●   ●   ●       │
      │     ●   ●   ●   ●       │
      │ 10mm          20mm →    │
      │                  15mm ↓ │
  0mm └─────────────────────────┘
     0mm                    100mm
     
测试区域: X轴 10-80mm, Y轴 5-135mm
```

**实现逻辑**：
```javascript
function calculateGridBounds(width, height, margin) {
    if (typeof margin === 'number') {
        // 统一边距
        return {
            xMin: margin,
            xMax: width - margin,
            yMin: margin,
            yMax: height - margin
        };
    } else {
        // 分别设置
        return {
            xMin: margin.left,
            xMax: width - margin.right,
            yMin: margin.bottom,
            yMax: height - margin.top
        };
    }
}
```

#### 绝对应力模式功能详细设计

**功能描述**：
支持输入基准测点的真实应力值，将相对应力分布转换为绝对应力值，适用于已知基准点应力的场景。

**两种计算模式**：

**模式1：相对应力模式**（默认）
```
σ_相对 = k × Δt

其中:
- 基准点: σ = 0 MPa（零点参考）
- 其他点: σ = 相对于基准点的应力差
```

**模式2：绝对应力模式**
```
σ_绝对 = σ_基准 + k × Δt

其中:
- σ_基准: 用户输入的基准点真实应力值
- k × Δt: 相对于基准点的应力差
- σ_绝对: 计算得到的绝对应力值
```

**界面设计**：
```
▼ 基准设置
  基准测点: [#1 ▼]
  
  应力计算模式:
    ● 相对应力模式（基准点 = 0 MPa）
    ○ 绝对应力模式
      基准点应力值 (MPa): [0]
      💡 正值=拉应力，负值=压应力，0=零应力
```

**应用场景**：
1. **已知基准点应力**：通过其他方法（如应变片）测得基准点应力
2. **多次测量对比**：不同时间测量同一试件，需要绝对值对比
3. **理论验证**：与有限元分析结果对比，需要绝对应力值
4. **质量控制**：产品应力需要满足绝对值规范

**计算示例**：

**示例1**：基准点有50 MPa拉应力
```
输入参数:
  基准应力: +50 MPa
  应力系数: k = 3.5 MPa/ns
  
测点#1（基准点）:
  Δt = 0 ns
  σ = 50 + (3.5 × 0) = 50 MPa
  
测点#2:
  Δt = +10 ns
  σ = 50 + (3.5 × 10) = 50 + 35 = 85 MPa（拉应力）
  
测点#3:
  Δt = -5 ns
  σ = 50 + (3.5 × -5) = 50 - 17.5 = 32.5 MPa（拉应力）
```

**示例2**：基准点有30 MPa压应力
```
输入参数:
  基准应力: -30 MPa
  应力系数: k = 3.5 MPa/ns
  
测点#1（基准点）:
  Δt = 0 ns
  σ = -30 + (3.5 × 0) = -30 MPa
  
测点#2:
  Δt = +10 ns
  σ = -30 + (3.5 × 10) = -30 + 35 = 5 MPa（小拉应力）
  
测点#3:
  Δt = -8 ns
  σ = -30 + (3.5 × -8) = -30 - 28 = -58 MPa（压应力）
```

**示例3**：基准点零应力（等效相对模式）
```
输入参数:
  基准应力: 0 MPa
  应力系数: k = 3.5 MPa/ns
  
测点#2:
  Δt = +10 ns
  σ = 0 + (3.5 × 10) = 35 MPa
  
结果与相对模式完全相同
```

**数据显示**：

**表格显示**（绝对应力模式）：
```
应力模式: 绝对应力（基准点 = +50 MPa）

# │ X(mm) │ Y(mm) │ Δt(ns) │ σ_相对(MPa) │ σ_绝对(MPa) │状态│
1 │ 10.0  │ 10.0  │  0.00  │    0.0      │   50.0      │ ✓  │
2 │ 30.0  │ 10.0  │ +12.3  │  +42.0      │   92.0      │ ✓  │
3 │ 50.0  │ 10.0  │  -8.5  │  -29.8      │   20.2      │ ✓  │
```

**云图显示**：
- 色标范围自动调整为绝对应力值
- 色标标题显示"绝对应力 (MPa)"
- 统计信息显示绝对应力的最大/最小值

**导出数据**：
```csv
#,X(mm),Y(mm),Δt(ns),σ_相对(MPa),σ_绝对(MPa),状态
1,10.0,10.0,0.00,0.0,50.0,已测
2,30.0,10.0,12.3,42.0,92.0,已测
3,50.0,10.0,-8.5,-29.8,20.2,已测
```

**实现逻辑**：
```python
def calculate_stress(time_diff, stress_coeff, baseline_stress=0):
    """计算应力值
    
    Args:
        time_diff: 声时差 (ns)
        stress_coeff: 应力系数 (MPa/ns)
        baseline_stress: 基准点应力值 (MPa)，默认0（相对模式）
    
    Returns:
        absolute_stress: 绝对应力值 (MPa)
    """
    relative_stress = stress_coeff * time_diff
    absolute_stress = baseline_stress + relative_stress
    return absolute_stress
```

**注意事项**：
- 基准点应力值支持正负输入（正=拉，负=压）
- 切换模式时，已采集数据自动重新计算
- 导出文件同时包含相对应力和绝对应力两列
- 云图和统计信息使用绝对应力值

#### 开发时间估算
- 形状编辑器：3天
- 高级布点：2天
- 实时更新：2天
- 自动化功能：2天
- 网格显示：0.5天
- 边距分别设置：0.5天
- 绝对应力模式：0.5天
- **总计：10.5天**

### 10.3 第三版功能（可选）

#### 高级功能
- ✅ 自定义多边形
- ✅ 导入 DXF/SVG 轮廓
- ✅ 手动绘制轮廓
- ✅ 多次测量对比
- ✅ 历史记录管理
- ✅ 3D 应力场显示
- ✅ 动画演示（采集过程回放）
- ✅ 报告自动生成（PDF）

#### 技术栈扩展
```python
# 新增依赖
requirements.txt:
  ezdxf>=1.0.0        # DXF文件读取
  svgpathtools>=1.5.0 # SVG路径解析
  reportlab>=4.0.0    # PDF生成
  matplotlib>=3.5.0   # 高级绘图
```

#### 开发时间估算
- 文件导入：3天
- 多次对比：2天
- 3D显示：4天
- 报告生成：3天
- **总计：12天**

### 10.4 开发优先级

#### P0（必须）- MVP
1. 矩形 + 网格布点
2. 手动采集
3. 基础云图
4. 数据表格

#### P1（重要）- 第二版
1. 圆形支持
2. 孔洞/缺口
3. 实时更新
4. 自动模式

#### P2（可选）- 第三版
1. 自定义多边形
2. 文件导入
3. 3D显示
4. 高级报告

### 10.5 注意事项

#### 相对应力说明
⚠️ **本模块测量的是相对应力分布，而非绝对应力值**

- 以基准测点（默认#1）为参考零点
- 显示各测点相对于基准点的应力差
- 如需绝对应力，请在"基准应力"中输入已知值进行校准
- 对于残余应力未知的复材板，建议关注应力梯度而非绝对值

#### 应力正负说明

**物理意义**：
- **拉应力**：正值（+），材料受拉伸
- **压应力**：负值（-），材料受压缩
- **零应力**：基准点，相对应力为0

**计算公式**：
```
σ = k × Δt

其中:
- σ: 应力值（MPa）
- k: 应力系数（由标定实验拟合得到，可正可负）
- Δt: 声时差（ns，相对于基准波形）
```

**系数正负由标定决定**：

**情况1**（常见材料）：
- 标定时：拉应力 → 声时增加 → Δt > 0
- 拟合得到：k > 0（正系数）
- 检测时：
  - Δt > 0 → σ > 0（拉应力）
  - Δt < 0 → σ < 0（压应力）

**情况2**（特殊材料）：
- 标定时：拉应力 → 声时减少 → Δt < 0
- 拟合得到：k < 0（负系数）
- 检测时：
  - Δt > 0 → σ < 0（压应力）
  - Δt < 0 → σ > 0（拉应力）

**系统处理**：
- 标定模块自动拟合应力系数 k（保留正负）
- 检测模块直接使用 σ = k × Δt 计算
- 自动保留应力值的正负号
- 云图根据应力正负显示不同颜色

**云图配色方案**：
```
拉应力区域（正值）：
  +100 MPa ■ 红色（最大拉应力）
   +50 MPa ■ 橙色
   +25 MPa ■ 黄色
  
零应力区域：
     0 MPa ■ 绿色（基准）
  
压应力区域（负值）：
   -25 MPa ■ 青色
   -50 MPa ■ 蓝色
  -100 MPa ■ 紫色（最大压应力）
```

**表格显示示例**：
```
# │ X(mm) │ Y(mm) │ Δt(ns) │ σ(MPa) │状态│
1 │ 10.0  │ 10.0  │  0.00  │   0.0  │ ✓  │ ← 基准点
2 │ 30.0  │ 10.0  │ +12.3  │ +45.2  │ ✓  │ ← 拉应力
3 │ 50.0  │ 10.0  │ -8.5   │ -28.5  │ ✓  │ ← 压应力
```

**注意事项**：
- 系统不假设应力与声时差的正负关系
- 完全由标定数据决定应力系数的正负
- 适用于各种材料和测试条件
- 云图自动适配正负值范围

#### 数据质量
- 前3个测点：不生成云图，仅显示离散点
- 4-8个测点：使用线性插值，标注"预览模式"
- 9个以上测点：使用三次插值，完整云图

#### 测点布置建议
- 应力梯度大的区域增加测点密度
- 边距建议 ≥ 5mm（避免边界效应）
- 孔洞周围建议加密布点
- 总测点数建议 16-49 个（平衡精度和效率）

---

**📄 文档说明**：本文档为第3部分（最后一部分），包含第7-10章内容。  
**⬅️ 上一部分**：[单轴应力检测模块设计文档-第2部分.md](./单轴应力检测模块设计文档-第2部分.md)  
**🏠 返回首页**：[单轴应力检测模块设计文档.md](./单轴应力检测模块设计文档.md)

---

**文档完成！** 🎉
