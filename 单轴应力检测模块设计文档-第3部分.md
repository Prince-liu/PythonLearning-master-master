# å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£ v1.0 - ç¬¬3éƒ¨åˆ†

> **åŒ…å«ç« èŠ‚**ï¼šç¬¬7ç«  å®æ—¶äº‘å›¾ç®—æ³•ã€ç¬¬8ç«  æ•°æ®ç»“æ„  
> **ä¸Šä¸€éƒ¨åˆ†**ï¼š[ç¬¬2éƒ¨åˆ†](./å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬2éƒ¨åˆ†.md)  
> **ä¸‹ä¸€éƒ¨åˆ†**ï¼š[ç¬¬4éƒ¨åˆ†](./å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬4éƒ¨åˆ†.md)

---

## 7. å®æ—¶äº‘å›¾ç®—æ³•

### 7.1 æ¸è¿›å¼æ’å€¼ç­–ç•¥

#### é˜¶æ®µåˆ’åˆ†
```python
def get_interpolation_strategy(n_measured):
    """æ ¹æ®å·²æµ‹ç‚¹æ•°é€‰æ‹©æ’å€¼ç­–ç•¥"""
    if n_measured < 3:
        return 'points_only'  # åªæ˜¾ç¤ºç¦»æ•£ç‚¹
    elif n_measured < 9:
        return 'linear'       # çº¿æ€§æ’å€¼ + è­¦å‘Š
    else:
        return 'cubic'        # ä¸‰æ¬¡æ’å€¼
```

#### å®æ—¶æ›´æ–°é€»è¾‘
```python
async def update_contour_realtime(new_point_data):
    """å®æ—¶æ›´æ–°äº‘å›¾"""
    # 1. æ·»åŠ æ–°æµ‹ç‚¹æ•°æ®
    measured_points.append(new_point_data)
    
    # 2. åˆ¤æ–­æ’å€¼ç­–ç•¥
    strategy = get_interpolation_strategy(len(measured_points))
    
    if strategy == 'points_only':
        # åªç»˜åˆ¶ç¦»æ•£ç‚¹
        draw_discrete_points(measured_points)
        show_message("æ•°æ®ç‚¹ä¸è¶³ï¼Œæš‚ä¸ç”Ÿæˆäº‘å›¾")
        
    elif strategy == 'linear':
        # çº¿æ€§æ’å€¼ + è­¦å‘Š
        contour_data = interpolate_linear(measured_points)
        draw_contour(contour_data, alpha=0.7)  # åŠé€æ˜
        show_warning("æ•°æ®ç‚¹è¾ƒå°‘ï¼Œäº‘å›¾ä»…ä¾›å‚è€ƒ")
        
    else:
        # å®Œæ•´ä¸‰æ¬¡æ’å€¼
        contour_data = interpolate_cubic(measured_points)
        draw_contour(contour_data, alpha=1.0)
```

### 7.2 æ’å€¼ç®—æ³•å®ç°

#### æ ¸å¿ƒä»£ç 
```python
from scipy.interpolate import griddata
import numpy as np

def interpolate_stress_field(points, shape_config, resolution=100):
    """æ’å€¼ç”Ÿæˆåº”åŠ›åœº"""
    # 1. æå–åæ ‡å’Œåº”åŠ›å€¼
    coords = np.array([[p['x'], p['y']] for p in points])
    stress = np.array([p['stress'] for p in points])
    
    # 2. ç”Ÿæˆå¯†é›†ç½‘æ ¼
    x_min, x_max = 0, shape_config['width']
    y_min, y_max = 0, shape_config['height']
    
    xi = np.linspace(x_min, x_max, resolution)
    yi = np.linspace(y_min, y_max, resolution)
    xi, yi = np.meshgrid(xi, yi)
    
    # 3. æ’å€¼è®¡ç®—
    method = 'cubic' if len(points) >= 9 else 'linear'
    zi = griddata(coords, stress, (xi, yi), method=method)
    
    # 4. é®ç½©æ— æ•ˆåŒºåŸŸï¼ˆå­”æ´ã€è¾¹ç•Œå¤–ï¼‰
    mask = create_shape_mask(xi, yi, shape_config)
    zi = np.ma.masked_where(~mask, zi)
    
    return xi, yi, zi
```

#### å½¢çŠ¶é®ç½©ä¸è¾¹è·åŒºåŸŸå¤„ç†

**è®¾è®¡åŸåˆ™**ï¼š
- **åªæ˜¾ç¤ºæœ‰å®æµ‹æ•°æ®çš„åŒºåŸŸ**ï¼ˆæµ‹è¯•åŒºåŸŸï¼‰
- **è¾¹è·åŒºåŸŸä¸æ˜¾ç¤ºäº‘å›¾**ï¼ˆæ— æ•°æ®åŒºåŸŸï¼Œé¿å…å¤–æ¨è¯¯å¯¼ï¼‰
- **æ¸…æ™°åŒºåˆ†**ï¼šç”¨ä¸åŒé¢œè‰²æ ‡è¯†æœ‰æ•°æ®åŒºå’Œæ— æ•°æ®åŒº

**é®ç½©ç±»å‹**ï¼š
1. **å½¢çŠ¶é®ç½©**ï¼šæ’é™¤æ ·ä»¶å¤–éƒ¨ã€å­”æ´ã€ç¼ºå£
2. **è¾¹è·é®ç½©**ï¼šæ’é™¤è¾¹è·åŒºåŸŸï¼ˆæ— æµ‹ç‚¹åŒºåŸŸï¼‰

```python
def create_shape_mask(xi, yi, shape_config, layout_config):
    """åˆ›å»ºå½¢çŠ¶é®ç½©ï¼ˆåŒ…å«è¾¹è·åŒºåŸŸé®ç½©ï¼‰"""
    from shapely.geometry import Point, Polygon, box
    
    # 1. åˆ›å»ºæ ·ä»¶å½¢çŠ¶å¯¹è±¡
    if shape_config['type'] == 'rectangle':
        shape = create_rectangle_shape(shape_config)
    elif shape_config['type'] == 'circle':
        shape = create_circle_shape(shape_config)
    else:
        shape = Polygon(shape_config['vertices'])
    
    # 2. åº”ç”¨å¸ƒå°”è¿ç®—ï¼ˆå‡å»å­”æ´ï¼‰
    for modifier in shape_config['modifiers']:
        if modifier['op'] == 'subtract':
            hole = create_hole_shape(modifier)
            shape = shape.difference(hole)
    
    # 3. åˆ›å»ºæµ‹è¯•åŒºåŸŸï¼ˆæ’é™¤è¾¹è·ï¼‰
    if layout_config['type'] == 'grid':
        margin = layout_config.get('margin', 0)
        test_region = box(
            margin,  # x_min
            margin,  # y_min
            shape_config['width'] - margin,   # x_max
            shape_config['height'] - margin   # y_max
        )
        # æµ‹è¯•åŒºåŸŸ = æ ·ä»¶å½¢çŠ¶ âˆ© æµ‹è¯•åŒºåŸŸ
        valid_region = shape.intersection(test_region)
    else:
        # å…¶ä»–å¸ƒç‚¹æ–¹å¼ï¼šä½¿ç”¨æ ·ä»¶å½¢çŠ¶ä½œä¸ºæœ‰æ•ˆåŒºåŸŸ
        valid_region = shape
    
    # 4. ç”Ÿæˆé®ç½©
    mask = np.zeros_like(xi, dtype=bool)
    for i in range(xi.shape[0]):
        for j in range(xi.shape[1]):
            point = Point(xi[i,j], yi[i,j])
            mask[i,j] = valid_region.contains(point)
    
    return mask
```

**è§†è§‰æ•ˆæœç¤ºä¾‹**ï¼š

```
æ ·ä»¶ 100Ã—150mmï¼Œè¾¹è· 10mmï¼Œæµ‹è¯•åŒºåŸŸ 80Ã—130mm

äº‘å›¾æ˜¾ç¤ºï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚ â† è¾¹è·åŒºï¼šæµ…ç°è‰²/ç™½è‰²
â”‚â–‘â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â–‘â”‚   (æ— æ•°æ®ï¼Œä¸æ˜¾ç¤ºäº‘å›¾)
â”‚â–‘â”‚ğŸ”´ğŸŸ ğŸŸ¡ğŸŸ¢ğŸ”µğŸŸ¢ğŸŸ¡ğŸŸ ğŸ”´      â”‚â–‘â”‚
â”‚â–‘â”‚ğŸŸ ğŸŸ¡ğŸŸ¢ğŸ”µğŸŸ¢ğŸ”µğŸŸ¢ğŸŸ¡ğŸŸ       â”‚â–‘â”‚
â”‚â–‘â”‚ğŸŸ¡ğŸŸ¢ğŸ”µğŸŸ¢ğŸŸ¡ğŸŸ¢ğŸ”µğŸŸ¢ğŸŸ¡      â”‚â–‘â”‚ â† æµ‹è¯•åŒºï¼šå½©è‰²äº‘å›¾
â”‚â–‘â”‚ğŸŸ¢ğŸ”µğŸŸ¢ğŸŸ¡ğŸŸ ğŸŸ¡ğŸŸ¢ğŸ”µğŸŸ¢      â”‚â–‘â”‚   (æœ‰å®æµ‹æ•°æ®)
â”‚â–‘â”‚ğŸ”µğŸŸ¢ğŸŸ¡ğŸŸ ğŸ”´ğŸŸ ğŸŸ¡ğŸŸ¢ğŸ”µ      â”‚â–‘â”‚
â”‚â–‘â”‚ğŸŸ¢ğŸŸ¡ğŸŸ ğŸ”´ğŸŸ ğŸ”´ğŸŸ ğŸŸ¡ğŸŸ¢      â”‚â–‘â”‚
â”‚â–‘â”‚ğŸŸ¡ğŸŸ ğŸ”´ğŸŸ ğŸŸ¡ğŸŸ ğŸ”´ğŸŸ ğŸŸ¡      â”‚â–‘â”‚
â”‚â–‘â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â–‘â”‚
â”‚â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚ â† è¾¹è·åŒºï¼šæµ…ç°è‰²/ç™½è‰²
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è¯´æ˜ï¼š
- å½©è‰²åŒºåŸŸï¼šæœ‰å®æµ‹æ•°æ®çš„æµ‹è¯•åŒºåŸŸ
- ç°è‰²åŒºåŸŸï¼šè¾¹è·åŒºåŸŸï¼ˆæ— æµ‹ç‚¹ï¼Œä¸æ’å€¼ï¼‰
- è™šçº¿æ¡†ï¼šæ ‡æ³¨æµ‹è¯•åŒºåŸŸè¾¹ç•Œï¼ˆå¯é€‰ï¼‰
```

**ç§‘å­¦æ€§è¯´æ˜**ï¼š
- âœ… **ä¸åšæ— æ ¹æ®çš„å¤–æ¨**ï¼šè¾¹è·åŒºåŸŸæ²¡æœ‰æµ‹ç‚¹ï¼Œä¸æ˜¾ç¤ºæ’å€¼ç»“æœ
- âœ… **æ¸…æ™°æ ‡è¯†**ï¼šç”¨æˆ·ä¸€çœ¼çœ‹å‡ºå“ªäº›åŒºåŸŸæœ‰æ•°æ®ï¼Œå“ªäº›æ²¡æœ‰
- âœ… **é¿å…è¯¯å¯¼**ï¼šé˜²æ­¢ç”¨æˆ·è¯¯ä»¥ä¸ºè¾¹è·åŒºåŸŸçš„åº”åŠ›å€¼æ˜¯çœŸå®æµ‹é‡çš„

**å®ç°ç»†èŠ‚**ï¼š
```python
# åº”ç”¨é®ç½©åçš„æ’å€¼ç»“æœ
zi_masked = np.ma.masked_where(~mask, zi)

# Canvas ç»˜åˆ¶æ—¶
# - é®ç½©åŒºåŸŸï¼šå¡«å……æµ…ç°è‰² #F5F5F5 æˆ–ç™½è‰²
# - æœ‰æ•ˆåŒºåŸŸï¼šç»˜åˆ¶å½©è‰²äº‘å›¾
# - è¾¹ç•Œçº¿ï¼šç”¨è™šçº¿æ ‡æ³¨æµ‹è¯•åŒºåŸŸè¾¹ç•Œï¼ˆå¯é€‰ï¼‰
```

### 7.3 æ€§èƒ½ä¼˜åŒ–

#### å¢é‡æ›´æ–°ï¼ˆé—®é¢˜5.2ï¼šæ™ºèƒ½äº‘å›¾æ›´æ–°ç­–ç•¥ï¼‰
```python
class ContourCache:
    """äº‘å›¾ç¼“å­˜ï¼Œæ”¯æŒå¢é‡æ›´æ–°"""
    def __init__(self):
        self.last_grid = None
        self.last_points = []
        self.cache = {}  # é—®é¢˜7.1ï¼šæ·»åŠ ç¼“å­˜æœºåˆ¶
    
    def should_full_update(self, new_points):
        """åˆ¤æ–­æ˜¯å¦éœ€è¦å®Œå…¨é‡æ–°è®¡ç®—"""
        # 1. æµ‹ç‚¹æ•°å˜åŒ–è¶…è¿‡20%
        if abs(len(new_points) - len(self.last_points)) / len(self.last_points) > 0.2:
            return True
        
        # 2. åº”åŠ›å€¼èŒƒå›´å˜åŒ–è¶…è¿‡30%
        if self._stress_range_changed(new_points, threshold=0.3):
            return True
        
        # 3. é¦–æ¬¡ç”Ÿæˆäº‘å›¾
        if self.last_grid is None:
            return True
        
        return False
    
    def update(self, new_point, shape_config, method='cubic'):
        """å¢é‡æ›´æ–°äº‘å›¾"""
        # æ·»åŠ æ–°æµ‹ç‚¹
        self.last_points.append(new_point)
        
        # åˆ¤æ–­æ›´æ–°ç­–ç•¥
        if self.should_full_update(self.last_points):
            # å®Œå…¨é‡æ–°è®¡ç®—
            return self._full_interpolation(self.last_points, shape_config, method)
        else:
            # å¢é‡æ›´æ–°ï¼šåªæ›´æ–°å—å½±å“çš„åŒºåŸŸ
            return self._incremental_update(new_point, shape_config, method)
    
    def _incremental_update(self, new_point, shape_config, method):
        """å¢é‡æ›´æ–°å—å½±å“çš„åŒºåŸŸ"""
        # 1. è®¡ç®—æ–°æµ‹ç‚¹çš„å½±å“èŒƒå›´ï¼ˆåŸºäºè·ç¦»ï¼‰
        influence_radius = self._calculate_influence_radius(new_point)
        
        # 2. æ‰¾å‡ºå—å½±å“çš„ç½‘æ ¼ç‚¹
        affected_mask = self._get_affected_region(new_point, influence_radius)
        
        # 3. åªé‡æ–°æ’å€¼å—å½±å“çš„åŒºåŸŸ
        xi_affected = self.last_grid['xi'][affected_mask]
        yi_affected = self.last_grid['yi'][affected_mask]
        
        # 4. ä½¿ç”¨æ‰€æœ‰æµ‹ç‚¹è¿›è¡Œå±€éƒ¨æ’å€¼
        coords = np.array([[p['x'], p['y']] for p in self.last_points])
        stress = np.array([p['stress'] for p in self.last_points])
        
        zi_affected = griddata(
            coords, stress, 
            (xi_affected, yi_affected), 
            method=method
        )
        
        # 5. æ›´æ–°ç½‘æ ¼
        self.last_grid['zi'][affected_mask] = zi_affected
        
        return self.last_grid
    
    def _calculate_influence_radius(self, point):
        """è®¡ç®—æµ‹ç‚¹çš„å½±å“åŠå¾„"""
        # åŸºäºæœ€è¿‘é‚»è·ç¦»çš„2å€
        if len(self.last_points) < 2:
            return 50.0  # é»˜è®¤å€¼
        
        distances = [
            np.sqrt((point['x'] - p['x'])**2 + (point['y'] - p['y'])**2)
            for p in self.last_points if p['id'] != point['id']
        ]
        
        return 2.0 * min(distances) if distances else 50.0
    
    def _get_affected_region(self, point, radius):
        """è·å–å—å½±å“çš„åŒºåŸŸé®ç½©"""
        xi, yi = self.last_grid['xi'], self.last_grid['yi']
        
        # è®¡ç®—æ¯ä¸ªç½‘æ ¼ç‚¹åˆ°æ–°æµ‹ç‚¹çš„è·ç¦»
        distances = np.sqrt(
            (xi - point['x'])**2 + (yi - point['y'])**2
        )
        
        # è¿”å›è·ç¦»å°äºå½±å“åŠå¾„çš„ç‚¹
        return distances <= radius
    
    def _full_interpolation(self, points, shape_config, method):
        """å®Œå…¨é‡æ–°æ’å€¼"""
        xi, yi, zi = interpolate_stress_field(points, shape_config, method)
        
        self.last_grid = {'xi': xi, 'yi': yi, 'zi': zi}
        return self.last_grid
    
    def _stress_range_changed(self, new_points, threshold=0.3):
        """æ£€æŸ¥åº”åŠ›å€¼èŒƒå›´æ˜¯å¦æ˜¾è‘—å˜åŒ–"""
        if not self.last_points:
            return True
        
        old_stress = [p['stress'] for p in self.last_points]
        new_stress = [p['stress'] for p in new_points]
        
        old_range = max(old_stress) - min(old_stress)
        new_range = max(new_stress) - min(new_stress)
        
        if old_range == 0:
            return True
        
        return abs(new_range - old_range) / old_range > threshold

# ä½¿ç”¨ç¤ºä¾‹
contour_cache = ContourCache()

async def update_contour_realtime(new_point_data):
    """å®æ—¶æ›´æ–°äº‘å›¾ï¼ˆä½¿ç”¨ç¼“å­˜å’Œå¢é‡æ›´æ–°ï¼‰"""
    # ä½¿ç”¨ç¼“å­˜çš„å¢é‡æ›´æ–°
    grid_data = contour_cache.update(
        new_point_data, 
        shape_config, 
        method='cubic'
    )
    
    # ç»˜åˆ¶äº‘å›¾
    draw_contour(grid_data)
```

#### ç¼“å­˜æœºåˆ¶ï¼ˆé—®é¢˜7.1ï¼‰
```python
from functools import lru_cache
import hashlib
import json

class ContourCacheManager:
    """äº‘å›¾ç¼“å­˜ç®¡ç†å™¨"""
    
    def __init__(self, max_cache_size=10):
        self.cache = {}
        self.max_size = max_cache_size
        self.access_count = {}
    
    def get_cache_key(self, exp_id, n_points, method, resolution):
        """ç”Ÿæˆç¼“å­˜é”®"""
        key_data = {
            'exp_id': exp_id,
            'n_points': n_points,
            'method': method,
            'resolution': resolution
        }
        key_str = json.dumps(key_data, sort_keys=True)
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, exp_id, n_points, method, resolution):
        """è·å–ç¼“å­˜çš„äº‘å›¾"""
        key = self.get_cache_key(exp_id, n_points, method, resolution)
        
        if key in self.cache:
            self.access_count[key] = self.access_count.get(key, 0) + 1
            return self.cache[key]
        
        return None
    
    def set(self, exp_id, n_points, method, resolution, contour_data):
        """ä¿å­˜äº‘å›¾åˆ°ç¼“å­˜"""
        key = self.get_cache_key(exp_id, n_points, method, resolution)
        
        # å¦‚æœç¼“å­˜å·²æ»¡ï¼Œåˆ é™¤æœ€å°‘ä½¿ç”¨çš„é¡¹
        if len(self.cache) >= self.max_size:
            self._evict_least_used()
        
        self.cache[key] = contour_data
        self.access_count[key] = 1
    
    def _evict_least_used(self):
        """åˆ é™¤æœ€å°‘ä½¿ç”¨çš„ç¼“å­˜é¡¹"""
        if not self.access_count:
            return
        
        least_used_key = min(self.access_count, key=self.access_count.get)
        del self.cache[least_used_key]
        del self.access_count[least_used_key]
    
    def invalidate(self, exp_id):
        """ä½¿æŸä¸ªå®éªŒçš„æ‰€æœ‰ç¼“å­˜å¤±æ•ˆ"""
        keys_to_remove = [
            key for key in self.cache.keys()
            if key.startswith(exp_id)
        ]
        
        for key in keys_to_remove:
            del self.cache[key]
            if key in self.access_count:
                del self.access_count[key]

# å…¨å±€ç¼“å­˜ç®¡ç†å™¨
cache_manager = ContourCacheManager(max_cache_size=10)

def get_cached_contour(exp_id, points, method='cubic', resolution=100):
    """è·å–ç¼“å­˜çš„äº‘å›¾æˆ–é‡æ–°è®¡ç®—"""
    n_points = len(points)
    
    # å°è¯•ä»ç¼“å­˜è·å–
    cached = cache_manager.get(exp_id, n_points, method, resolution)
    if cached is not None:
        return cached
    
    # ç¼“å­˜æœªå‘½ä¸­ï¼Œé‡æ–°è®¡ç®—
    xi, yi, zi = interpolate_stress_field(points, shape_config, method, resolution)
    contour_data = {'xi': xi, 'yi': yi, 'zi': zi}
    
    # ä¿å­˜åˆ°ç¼“å­˜
    cache_manager.set(exp_id, n_points, method, resolution, contour_data)
    
    return contour_data
```

#### åˆ†è¾¨ç‡è‡ªé€‚åº”ï¼ˆé—®é¢˜7.2ï¼šå¤§æ•°æ®é‡å¤„ç†ç­–ç•¥ï¼‰
```python
def get_adaptive_resolution(n_points, stage, max_points=100):
    """æ ¹æ®æµ‹ç‚¹æ•°å’Œé˜¶æ®µé€‰æ‹©åˆ†è¾¨ç‡
    
    ç­–ç•¥ï¼š
    - æµ‹ç‚¹å°‘æ—¶ï¼šä½åˆ†è¾¨ç‡ï¼Œå¿«é€Ÿæ›´æ–°
    - æµ‹ç‚¹å¤šæ—¶ï¼šé«˜åˆ†è¾¨ç‡ï¼Œç²¾ç»†æ˜¾ç¤º
    - é‡‡é›†é˜¶æ®µï¼šä¼˜å…ˆé€Ÿåº¦
    - åˆ†æé˜¶æ®µï¼šä¼˜å…ˆè´¨é‡
    """
    if stage == 'measuring':
        # é‡‡é›†é˜¶æ®µï¼šä½åˆ†è¾¨ç‡ï¼Œå¿«é€Ÿæ›´æ–°
        base_resolution = 50
        # æ¯ä¸ªæµ‹ç‚¹è´¡çŒ®5ä¸ªç½‘æ ¼ç‚¹
        resolution = min(base_resolution + n_points * 5, 100)
    else:
        # åˆ†æé˜¶æ®µï¼šé«˜åˆ†è¾¨ç‡ï¼Œç²¾ç»†æ˜¾ç¤º
        base_resolution = 100
        # æ¯ä¸ªæµ‹ç‚¹è´¡çŒ®10ä¸ªç½‘æ ¼ç‚¹
        resolution = min(base_resolution + n_points * 10, 300)
    
    return int(resolution)

def interpolate_large_dataset(points, shape_config, method='cubic'):
    """å¤„ç†å¤§æ•°æ®é‡çš„æ’å€¼ï¼ˆé—®é¢˜7.2ï¼‰"""
    n_points = len(points)
    
    if n_points <= 50:
        # å°æ•°æ®é›†ï¼šç›´æ¥æ’å€¼
        return interpolate_stress_field(points, shape_config, method)
    
    elif n_points <= 200:
        # ä¸­ç­‰æ•°æ®é›†ï¼šåˆ†å—æ’å€¼
        return _block_interpolation(points, shape_config, method)
    
    else:
        # å¤§æ•°æ®é›†ï¼šå¤šçº¿ç¨‹æ’å€¼
        return _parallel_interpolation(points, shape_config, method)

def _block_interpolation(points, shape_config, method, block_size=50):
    """åˆ†å—æ’å€¼"""
    # å°†åŒºåŸŸåˆ†æˆå¤šä¸ªå—
    blocks = _divide_into_blocks(shape_config, block_size)
    
    results = []
    for block in blocks:
        # æ‰¾å‡ºè¯¥å—å†…åŠé™„è¿‘çš„æµ‹ç‚¹
        block_points = _get_points_in_block(points, block, margin=20)
        
        # å¯¹è¯¥å—è¿›è¡Œæ’å€¼
        xi, yi, zi = interpolate_stress_field(
            block_points, block, method
        )
        
        results.append({'xi': xi, 'yi': yi, 'zi': zi, 'block': block})
    
    # åˆå¹¶æ‰€æœ‰å—çš„ç»“æœ
    return _merge_blocks(results)

def _parallel_interpolation(points, shape_config, method):
    """å¤šçº¿ç¨‹å¹¶è¡Œæ’å€¼"""
    from concurrent.futures import ThreadPoolExecutor
    
    # åˆ†æˆ4ä¸ªåŒºåŸŸ
    regions = _divide_into_regions(shape_config, n_regions=4)
    
    with ThreadPoolExecutor(max_workers=4) as executor:
        futures = []
        for region in regions:
            future = executor.submit(
                interpolate_stress_field,
                points, region, method
            )
            futures.append(future)
        
        results = [f.result() for f in futures]
    
    # åˆå¹¶ç»“æœ
    return _merge_regions(results)
```

### 7.4 è§†è§‰æ•ˆæœ

#### é¢œè‰²æ˜ å°„
```python
import matplotlib.cm as cm

def apply_colormap(stress_data, vmin=None, vmax=None, cmap='rainbow'):
    """åº”ç”¨é¢œè‰²æ˜ å°„"""
    if vmin is None:
        vmin = np.nanmin(stress_data)
    if vmax is None:
        vmax = np.nanmax(stress_data)
    
    # å½’ä¸€åŒ–
    norm = (stress_data - vmin) / (vmax - vmin)
    
    # åº”ç”¨è‰²å›¾
    colormap = cm.get_cmap(cmap)
    rgba = colormap(norm)
    
    return rgba
```

#### ç­‰å€¼çº¿å åŠ 
```python
def draw_contour_with_isolines(xi, yi, zi, levels=10):
    """ç»˜åˆ¶äº‘å›¾ + ç­‰å€¼çº¿"""
    # å¡«å……äº‘å›¾
    contourf(xi, yi, zi, levels=100, cmap='rainbow')
    
    # å åŠ ç­‰å€¼çº¿
    contour(xi, yi, zi, levels=levels, colors='black', 
            linewidths=0.5, alpha=0.5)
    
    # æ ‡æ³¨ç­‰å€¼çº¿æ•°å€¼
    clabel(contour_lines, inline=True, fontsize=8)
```

#### æµ‹ç‚¹æ ‡è®°
```python
def draw_point_markers(points, current_point_id=None):
    """ç»˜åˆ¶æµ‹ç‚¹æ ‡è®°"""
    for point in points:
        if point['status'] == 'measured':
            color = 'green'
            marker = 'â—'
        elif point['id'] == current_point_id:
            color = 'yellow'
            marker = 'â—‰'  # é«˜äº®å½“å‰ç‚¹
        else:
            color = 'gray'
            marker = 'â—‹'
        
        draw_marker(point['x'], point['y'], marker, color)
        draw_text(point['x'], point['y'], f"#{point['id']}")
```

---

## 8. æ•°æ®ç»“æ„

### 8.1 æ•°æ®åº“è¡¨è®¾è®¡ï¼ˆSQLiteï¼‰

#### è¡¨1ï¼šfield_experimentsï¼ˆåº”åŠ›åœºå®éªŒï¼‰
```sql
CREATE TABLE field_experiments (
    id TEXT PRIMARY KEY,              -- å®éªŒIDï¼Œå¦‚ "FIELD001"
    name TEXT NOT NULL,               -- å®éªŒåç§°
    calibration_exp_id TEXT NOT NULL, -- å…³è”çš„æ ‡å®šå®éªŒID
    calibration_direction TEXT,       -- æ ‡å®šæ–¹å‘ï¼ˆå¦‚ "0Â°"ï¼‰
    shape_config TEXT NOT NULL,       -- å½¢çŠ¶é…ç½®ï¼ˆJSONï¼‰
    point_layout TEXT NOT NULL,       -- æµ‹ç‚¹å¸ƒå±€ï¼ˆJSONï¼‰
    baseline_point_id INTEGER,        -- åŸºå‡†æµ‹ç‚¹ID
    baseline_stress REAL,             -- åŸºå‡†åº”åŠ›å€¼ï¼ˆå¯é€‰ï¼‰
    status TEXT DEFAULT 'planning',   -- å®éªŒçŠ¶æ€
    created_at TEXT,                  -- åˆ›å»ºæ—¶é—´
    completed_at TEXT,                -- å®Œæˆæ—¶é—´
    notes TEXT,                       -- å¤‡æ³¨
    
    -- æ–°å¢ï¼šå®éªŒé…ç½®å¿«ç…§ï¼ˆé—®é¢˜1.1ï¼‰
    config_snapshot TEXT,             -- å®Œæ•´é…ç½®å¿«ç…§ï¼ˆJSONï¼‰ï¼ŒåŒ…æ‹¬ï¼š
                                      -- - æ ‡å®šæ•°æ®ï¼ˆkå€¼ã€RÂ²ã€æ–œç‡ã€æˆªè·ï¼‰
                                      -- - å½¢çŠ¶é…ç½®
                                      -- - å¸ƒç‚¹å‚æ•°
                                      -- - é™å™ªè®¾ç½®
                                      -- - ç¤ºæ³¢å™¨è®¾ç½®
    
    -- æ–°å¢ï¼šå®éªŒå…ƒæ•°æ®ï¼ˆé—®é¢˜4.2ï¼‰
    operator TEXT,                    -- æ“ä½œå‘˜å§“å
    temperature REAL,                 -- ç¯å¢ƒæ¸©åº¦ï¼ˆâ„ƒï¼‰
    humidity REAL,                    -- ç¯å¢ƒæ¹¿åº¦ï¼ˆ%ï¼‰
    scope_model TEXT,                 -- ç¤ºæ³¢å™¨å‹å·
    probe_model TEXT,                 -- æ¢å¤´å‹å·
    sample_material TEXT,             -- è¯•ä»¶ææ–™
    sample_thickness REAL,            -- è¯•ä»¶åšåº¦ï¼ˆmmï¼‰
    test_purpose TEXT                 -- å®éªŒç›®çš„
);
```

#### è¡¨2ï¼šfield_pointsï¼ˆæµ‹ç‚¹æ•°æ®ï¼‰
```sql
CREATE TABLE field_points (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    experiment_id TEXT NOT NULL,      -- æ‰€å±å®éªŒID
    point_index INTEGER NOT NULL,     -- æµ‹ç‚¹ç¼–å·
    x_coord REAL NOT NULL,            -- Xåæ ‡ (mm)
    y_coord REAL NOT NULL,            -- Yåæ ‡ (mm)
    r_coord REAL,                     -- æåæ ‡åŠå¾„ (mm)ï¼Œå¯é€‰
    theta_coord REAL,                 -- æåæ ‡è§’åº¦ (Â°)ï¼Œå¯é€‰
    time_diff REAL,                   -- å£°æ—¶å·® (ns)
    stress_value REAL,                -- åº”åŠ›å€¼ (MPa)
    status TEXT DEFAULT 'pending',    -- æµ‹ç‚¹çŠ¶æ€
    measured_at TEXT,                 -- æµ‹é‡æ—¶é—´
    waveform_file TEXT,               -- HDF5æ–‡ä»¶è·¯å¾„
    quality_score REAL,               -- ä¿¡å·è´¨é‡è¯„åˆ†
    is_suspicious BOOLEAN DEFAULT 0,  -- æ˜¯å¦å¯ç–‘æ•°æ®
    FOREIGN KEY (experiment_id) REFERENCES field_experiments(id)
);

CREATE INDEX idx_field_points_exp ON field_points(experiment_id);
```

**æåæ ‡æ•°æ®å¤„ç†è¯´æ˜ï¼ˆé—®é¢˜4.3ï¼‰**ï¼š

**å­˜å‚¨ç­–ç•¥**ï¼š
- æ•°æ®åº“ä¸­**åŒæ—¶å­˜å‚¨ç¬›å¡å°”åæ ‡å’Œæåæ ‡**
- ç¬›å¡å°”åæ ‡ (x, y) æ˜¯ä¸»è¦åæ ‡ï¼Œå§‹ç»ˆå­˜åœ¨
- æåæ ‡ (r, Î¸) æ˜¯è¾…åŠ©åæ ‡ï¼Œä»…åœ¨åœ†å½¢è¯•ä»¶+æåæ ‡å¸ƒç‚¹æ—¶å­˜åœ¨

**åæ ‡è½¬æ¢**ï¼š
```python
def save_point_with_coordinates(point, shape_config, layout_config):
    """ä¿å­˜æµ‹ç‚¹æ—¶è‡ªåŠ¨è®¡ç®—å¹¶å­˜å‚¨ä¸¤ç§åæ ‡ï¼ˆé—®é¢˜4.3ï¼‰"""
    x, y = point['x'], point['y']
    
    # å§‹ç»ˆä¿å­˜ç¬›å¡å°”åæ ‡
    point_data = {
        'x_coord': x,
        'y_coord': y,
        'r_coord': None,
        'theta_coord': None
    }
    
    # å¦‚æœæ˜¯åœ†å½¢è¯•ä»¶ + æåæ ‡å¸ƒç‚¹ï¼Œè®¡ç®—å¹¶ä¿å­˜æåæ ‡
    if (shape_config['type'] == 'circle' and 
        layout_config['type'] == 'polar'):
        
        # ä»é…ç½®å¿«ç…§ä¸­è·å–åœ†å¿ƒåæ ‡ï¼ˆç¡®ä¿ä¸€è‡´æ€§ï¼‰
        center_x = shape_config['center_x']
        center_y = shape_config['center_y']
        
        # è®¡ç®—æåæ ‡
        r, theta = cartesian_to_polar(x, y, center_x, center_y)
        
        point_data['r_coord'] = r
        point_data['theta_coord'] = theta
    
    return point_data

def cartesian_to_polar(x, y, center_x, center_y):
    """ç¬›å¡å°”åæ ‡è½¬æåæ ‡
    
    å‚æ•°:
        x, y: ç¬›å¡å°”åæ ‡
        center_x, center_y: æåæ ‡åŸç‚¹
    
    è¿”å›:
        r: åŠå¾„ (mm)
        theta: è§’åº¦ (Â°)ï¼ŒèŒƒå›´ 0-360ï¼Œ0Â°ä¸ºæ­£ä¸œæ–¹å‘
    """
    dx = x - center_x
    dy = y - center_y
    
    # è®¡ç®—åŠå¾„
    r = np.sqrt(dx**2 + dy**2)
    
    # è®¡ç®—è§’åº¦ï¼ˆå¼§åº¦ï¼‰
    theta_rad = np.arctan2(dy, dx)
    
    # è½¬æ¢ä¸ºè§’åº¦ï¼ˆ0-360Â°ï¼‰
    theta_deg = np.degrees(theta_rad)
    if theta_deg < 0:
        theta_deg += 360
    
    return round(r, 2), round(theta_deg, 2)

def polar_to_cartesian(r, theta, center_x, center_y):
    """æåæ ‡è½¬ç¬›å¡å°”åæ ‡ï¼ˆåå‘è½¬æ¢ï¼‰"""
    theta_rad = np.radians(theta)
    
    x = center_x + r * np.cos(theta_rad)
    y = center_y + r * np.sin(theta_rad)
    
    return round(x, 2), round(y, 2)
```

**é…ç½®å¿«ç…§ä¸­ä¿å­˜åœ†å¿ƒ**ï¼š
```python
# åœ¨ config_snapshot ä¸­ä¿å­˜æåæ ‡åŸç‚¹
config_snapshot = {
    "shape": {
        "type": "circle",
        "center_x": 50.0,
        "center_y": 50.0,
        "outer_radius": 40.0
    },
    "layout": {
        "type": "polar",
        "polar_center": {  # æ˜ç¡®è®°å½•æåæ ‡åŸç‚¹
            "x": 50.0,
            "y": 50.0
        }
    }
}
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡**ï¼š
1. âœ… **æ•°æ®å®Œæ•´æ€§**ï¼šä¸¤ç§åæ ‡éƒ½å­˜å‚¨ï¼Œäº’ä¸ä¾èµ–
2. âœ… **çµæ´»æ€§**ï¼šå¯ä»¥éšæ—¶åœ¨ä¸¤ç§åæ ‡ç³»ä¹‹é—´åˆ‡æ¢æ˜¾ç¤º
3. âœ… **å¯è¿½æº¯æ€§**ï¼šå³ä½¿å½¢çŠ¶é…ç½®æ”¹å˜ï¼Œå†å²æ•°æ®çš„æåæ ‡ä»ç„¶æœ‰æ•ˆï¼ˆå› ä¸ºåœ†å¿ƒä¿å­˜åœ¨é…ç½®å¿«ç…§ä¸­ï¼‰
4. âœ… **å…¼å®¹æ€§**ï¼šçŸ©å½¢è¯•ä»¶ä¸éœ€è¦æåæ ‡ï¼Œr_coord å’Œ theta_coord ä¸º NULL

**å‰ç«¯åæ ‡æ˜¾ç¤ºåˆ‡æ¢**ï¼š
```javascript
// ç”¨æˆ·å¯ä»¥æ‰‹åŠ¨åˆ‡æ¢åæ ‡æ˜¾ç¤º
function toggleCoordinateDisplay() {
    const currentMode = getCoordinateDisplayMode();  // 'cartesian' | 'polar'
    
    if (currentMode === 'cartesian') {
        // åˆ‡æ¢åˆ°æåæ ‡æ˜¾ç¤º
        setCoordinateDisplayMode('polar');
        updateTableHeaders(['#', 'R(mm)', 'Î¸(Â°)', 'Î”t(ns)', 'Ïƒ(MPa)', 'çŠ¶æ€']);
    } else {
        // åˆ‡æ¢åˆ°ç¬›å¡å°”åæ ‡æ˜¾ç¤º
        setCoordinateDisplayMode('cartesian');
        updateTableHeaders(['#', 'X(mm)', 'Y(mm)', 'Î”t(ns)', 'Ïƒ(MPa)', 'çŠ¶æ€']);
    }
    
    // é‡æ–°æ¸²æŸ“è¡¨æ ¼
    renderTable();
}
```

#### è¡¨3ï¼šfield_metadataï¼ˆäº‘å›¾å…ƒæ•°æ®ï¼‰
```sql
CREATE TABLE field_metadata (
    experiment_id TEXT PRIMARY KEY,
    interpolation_method TEXT,        -- æ’å€¼æ–¹æ³•
    grid_resolution INTEGER,          -- ç½‘æ ¼åˆ†è¾¨ç‡
    colormap TEXT,                    -- è‰²å›¾åç§°
    vmin REAL,                        -- è‰²æ ‡æœ€å°å€¼
    vmax REAL,                        -- è‰²æ ‡æœ€å¤§å€¼
    contour_image_path TEXT,          -- äº‘å›¾å›¾ç‰‡è·¯å¾„
    statistics TEXT,                  -- ç»Ÿè®¡ä¿¡æ¯ï¼ˆJSONï¼‰
    FOREIGN KEY (experiment_id) REFERENCES field_experiments(id)
);
```

#### è¡¨4ï¼šschema_versionï¼ˆæ•°æ®åº“ç‰ˆæœ¬æ§åˆ¶ï¼‰ï¼ˆé—®é¢˜1.2ï¼‰
```sql
CREATE TABLE schema_version (
    version INTEGER PRIMARY KEY,      -- ç‰ˆæœ¬å·
    applied_at TEXT NOT NULL,         -- åº”ç”¨æ—¶é—´
    description TEXT,                 -- ç‰ˆæœ¬æè¿°
    migration_script TEXT             -- è¿ç§»è„šæœ¬ï¼ˆå¯é€‰ï¼‰
);

-- æ’å…¥åˆå§‹ç‰ˆæœ¬
INSERT INTO schema_version (version, applied_at, description) 
VALUES (1, datetime('now'), 'åˆå§‹æ•°æ®åº“ç»“æ„');
```

**ç‰ˆæœ¬è¿ç§»ç¤ºä¾‹**ï¼š
```python
# æ•°æ®åº“è¿ç§»ç®¡ç†å™¨
class DatabaseMigration:
    def __init__(self, db_path):
        self.conn = sqlite3.connect(db_path)
        self.cursor = self.conn.cursor()
    
    def get_current_version(self):
        """è·å–å½“å‰æ•°æ®åº“ç‰ˆæœ¬"""
        try:
            self.cursor.execute("SELECT MAX(version) FROM schema_version")
            result = self.cursor.fetchone()
            return result[0] if result[0] else 0
        except:
            return 0
    
    def migrate_to_version_2(self):
        """è¿ç§»åˆ°ç‰ˆæœ¬2ï¼šæ·»åŠ å®éªŒå…ƒæ•°æ®å­—æ®µ"""
        self.cursor.execute("""
            ALTER TABLE field_experiments 
            ADD COLUMN operator TEXT
        """)
        self.cursor.execute("""
            ALTER TABLE field_experiments 
            ADD COLUMN temperature REAL
        """)
        # ... å…¶ä»–å­—æ®µ
        
        self.cursor.execute("""
            INSERT INTO schema_version (version, applied_at, description)
            VALUES (2, datetime('now'), 'æ·»åŠ å®éªŒå…ƒæ•°æ®å­—æ®µ')
        """)
        self.conn.commit()
    
    def apply_migrations(self):
        """åº”ç”¨æ‰€æœ‰å¾…æ‰§è¡Œçš„è¿ç§»"""
        current_version = self.get_current_version()
        
        migrations = {
            2: self.migrate_to_version_2,
            # 3: self.migrate_to_version_3,
            # ...
        }
        
        for version, migration_func in sorted(migrations.items()):
            if version > current_version:
                print(f"åº”ç”¨è¿ç§»ï¼šç‰ˆæœ¬ {version}")
                migration_func()
```

### 8.2 HDF5 æ–‡ä»¶ç»„ç»‡

#### æ–‡ä»¶ç»“æ„ï¼ˆé—®é¢˜1.3ï¼šä¼˜åŒ–åçš„ç»„ç»‡æ–¹å¼ï¼‰

**æ”¹è¿›æ–¹æ¡ˆ**ï¼šä½¿ç”¨å•ä¸ªHDF5æ–‡ä»¶å­˜å‚¨æ‰€æœ‰æµ‹ç‚¹æ•°æ®ï¼Œå‡å°‘æ–‡ä»¶ç³»ç»Ÿå¼€é”€

```
data/uniaxial_field/
â”œâ”€â”€ FIELD001.h5                # å®éªŒFIELD001çš„æ‰€æœ‰æ•°æ®
â”œâ”€â”€ FIELD002.h5                # å®éªŒFIELD002çš„æ‰€æœ‰æ•°æ®
â””â”€â”€ ...
```

**ä¼˜ç‚¹**ï¼š
- âœ… å‡å°‘æ–‡ä»¶æ•°é‡ï¼ˆ25ä¸ªæµ‹ç‚¹ = 1ä¸ªæ–‡ä»¶ï¼Œè€Œé25ä¸ªæ–‡ä»¶ï¼‰
- âœ… æé«˜I/Oæ•ˆç‡ï¼ˆä¸€æ¬¡æ‰“å¼€ï¼Œå¤šæ¬¡è¯»å†™ï¼‰
- âœ… ä¾¿äºå¤‡ä»½å’Œä¼ è¾“
- âœ… æ”¯æŒåŸå­æ“ä½œï¼ˆäº‹åŠ¡æ€§ï¼‰

#### å•ä¸ªå®éªŒHDF5ç»“æ„

```python
# FIELD001.h5
{
    'metadata': {
        'experiment_id': 'FIELD001',
        'name': 'é“æ¿åº”åŠ›åˆ†å¸ƒæµ‹è¯•',
        'created_at': '2025-12-19 14:30:00',
        'operator': 'å¼ ä¸‰',
        'temperature': 25.5,
        'humidity': 45.0
    },
    
    'config_snapshot': {
        'calibration': {
            'k': 3.67,
            'r_squared': 0.9987,
            'slope': 0.2725,
            'intercept': 0.0,
            'source': 'local',
            'exp_id': 'EXP003',
            'direction': '0Â°'
        },
        'shape': {
            'type': 'rectangle',
            'width': 100,
            'height': 150
        },
        'layout': {
            'type': 'grid',
            'rows': 5,
            'cols': 5,
            'margin': 10
        },
        'denoise': {
            'method': 'wavelet',
            'wavelet': 'sym6',
            'level': 5,
            'threshold_mode': 'soft',
            'threshold_rule': 'heursure'
        },
        'scope_settings': {
            'model': 'RIGOL DS1054Z',
            'sample_rate': 1e9,
            'memory_depth': 12000000,
            'timebase': 1e-6
        }
    },
    
    'baseline': {
        'point_id': 1,
        'waveform': {
            'time': [array],
            'voltage': [array],
            'sample_rate': 1e9
        },
        'captured_at': '2025-12-19 14:35:00'
    },
    
    'points': {
        'point_001': {
            'metadata': {
                'point_id': 1,
                'x_coord': 10.0,
                'y_coord': 10.0,
                'measured_at': '2025-12-19 14:35:00'
            },
            'waveform': {
                'time': [array],
                'voltage': [array],
                'sample_rate': 1e9
            },
            'analysis': {
                'time_diff': 0.0,
                'stress': 0.0,
                'snr': 28.5,
                'quality_score': 0.98
            }
        },
        'point_002': {
            'metadata': {...},
            'waveform': {...},
            'analysis': {...}
        },
        # ... å…¶ä»–æµ‹ç‚¹
    },
    
    'contour': {
        'grid': {
            'xi': [2D array],
            'yi': [2D array],
            'zi': [2D array]
        },
        'metadata': {
            'interpolation_method': 'cubic',
            'resolution': 200,
            'n_points': 25,
            'generated_at': '2025-12-19 15:45:30'
        }
    }
}
```

#### HDF5æ“ä½œç¤ºä¾‹

```python
import h5py
import numpy as np

class FieldExperimentHDF5:
    """åº”åŠ›åœºå®éªŒHDF5æ–‡ä»¶ç®¡ç†"""
    
    def __init__(self, exp_id):
        self.exp_id = exp_id
        self.file_path = f'data/uniaxial_field/{exp_id}.h5'
    
    def create_experiment_file(self, metadata, config_snapshot):
        """åˆ›å»ºå®éªŒHDF5æ–‡ä»¶"""
        with h5py.File(self.file_path, 'w') as f:
            # ä¿å­˜å…ƒæ•°æ®
            meta_group = f.create_group('metadata')
            for key, value in metadata.items():
                meta_group.attrs[key] = value
            
            # ä¿å­˜é…ç½®å¿«ç…§
            config_group = f.create_group('config_snapshot')
            self._save_dict_to_group(config_group, config_snapshot)
            
            # åˆ›å»ºæµ‹ç‚¹ç»„
            f.create_group('points')
    
    def save_point_data(self, point_id, waveform, analysis):
        """ä¿å­˜æµ‹ç‚¹æ•°æ®"""
        with h5py.File(self.file_path, 'a') as f:
            point_key = f'point_{point_id:03d}'
            point_group = f['points'].create_group(point_key)
            
            # ä¿å­˜æ³¢å½¢
            wf_group = point_group.create_group('waveform')
            wf_group.create_dataset('time', data=waveform['time'])
            wf_group.create_dataset('voltage', data=waveform['voltage'])
            wf_group.attrs['sample_rate'] = waveform['sample_rate']
            
            # ä¿å­˜åˆ†æç»“æœ
            analysis_group = point_group.create_group('analysis')
            for key, value in analysis.items():
                analysis_group.attrs[key] = value
    
    def load_point_data(self, point_id):
        """åŠ è½½æµ‹ç‚¹æ•°æ®"""
        with h5py.File(self.file_path, 'r') as f:
            point_key = f'point_{point_id:03d}'
            point_group = f['points'][point_key]
            
            waveform = {
                'time': point_group['waveform']['time'][:],
                'voltage': point_group['waveform']['voltage'][:],
                'sample_rate': point_group['waveform'].attrs['sample_rate']
            }
            
            analysis = dict(point_group['analysis'].attrs)
            
            return {'waveform': waveform, 'analysis': analysis}
    
    def _save_dict_to_group(self, group, data):
        """é€’å½’ä¿å­˜å­—å…¸åˆ°HDF5ç»„"""
        for key, value in data.items():
            if isinstance(value, dict):
                subgroup = group.create_group(key)
                self._save_dict_to_group(subgroup, value)
            else:
                group.attrs[key] = value
```

### 8.3 å‰ç«¯æ•°æ®æ ¼å¼

#### å½¢çŠ¶é…ç½®å¯¹è±¡
```javascript
const shapeConfig = {
    type: 'rectangle',  // 'rectangle' | 'circle' | 'polygon'
    
    // çŸ©å½¢å‚æ•°
    width: 100,
    height: 150,
    
    // åœ†å½¢å‚æ•°
    centerX: 50,
    centerY: 50,
    outerRadius: 40,
    innerRadius: 0,
    startAngle: 0,
    endAngle: 360,
    
    // å¤šè¾¹å½¢å‚æ•°
    vertices: [[0,0], [100,0], [100,100], [0,100]],
    
    // å¸ƒå°”è¿ç®—
    modifiers: [
        {
            op: 'subtract',  // 'subtract' | 'add'
            shape: 'circle',
            centerX: 50,
            centerY: 75,
            radius: 20
        }
    ]
};
```

#### æµ‹ç‚¹æ•°æ®å¯¹è±¡
```javascript
const pointData = {
    id: 1,
    x: 10.0,
    y: 10.0,
    timeDiff: 45.23,
    stress: 120.5,
    status: 'measured',  // 'pending' | 'measuring' | 'measured' | 'skipped' | 'error'
    measuredAt: '2025-12-19 14:30:15',
    qualityScore: 0.95,
    isSuspicious: false
};
```

#### äº‘å›¾æ•°æ®å¯¹è±¡
```javascript
const contourData = {
    grid: {
        xi: [[...]],  // 2D array
        yi: [[...]],
        zi: [[...]]   // åº”åŠ›å€¼
    },
    points: [
        {id: 1, x: 10, y: 10, stress: 120.5},
        // ...
    ],
    metadata: {
        method: 'cubic',
        resolution: 200,
        vmin: 0,
        vmax: 200,
        confidence: 'full'  // 'preview' | 'full'
    }
};
```

---

**ğŸ“„ æ–‡æ¡£è¯´æ˜**ï¼šæœ¬æ–‡æ¡£ä¸ºç¬¬3éƒ¨åˆ†ï¼ŒåŒ…å«ç¬¬7-8ç« å†…å®¹ã€‚  
**â¬…ï¸ ä¸Šä¸€éƒ¨åˆ†**ï¼š[å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬2éƒ¨åˆ†.md](./å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬2éƒ¨åˆ†.md)  
**â¡ï¸ ä¸‹ä¸€éƒ¨åˆ†**ï¼š[å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬4éƒ¨åˆ†.md](./å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬4éƒ¨åˆ†.md)
