# å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£ v1.0

> **æ¨¡å—åç§°**ï¼šstress_detection_uniaxial  
> **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-12-19  
> **æœ€åæ›´æ–°**ï¼š2025-12-19

---

## ç›®å½•

1. [æ¨¡å—æ¦‚è¿°](#1-æ¨¡å—æ¦‚è¿°)
2. [ä»£ç æ¶æ„è®¾è®¡](#2-ä»£ç æ¶æ„è®¾è®¡)
3. [ç•Œé¢è®¾è®¡](#3-ç•Œé¢è®¾è®¡) - è§ç¬¬1.5éƒ¨åˆ†
4. [å½¢çŠ¶å®šä¹‰åŠŸèƒ½](#4-å½¢çŠ¶å®šä¹‰åŠŸèƒ½) - è§ç¬¬2éƒ¨åˆ†
5. [å¸ƒç‚¹ç­–ç•¥](#5-å¸ƒç‚¹ç­–ç•¥) - è§ç¬¬2éƒ¨åˆ†
6. [é‡‡é›†æµç¨‹](#6-é‡‡é›†æµç¨‹) - è§ç¬¬2éƒ¨åˆ†
7. [å®æ—¶äº‘å›¾ç®—æ³•](#7-å®æ—¶äº‘å›¾ç®—æ³•) - è§ç¬¬3éƒ¨åˆ†
8. [æ•°æ®ç»“æ„](#8-æ•°æ®ç»“æ„) - è§ç¬¬3éƒ¨åˆ†
9. [APIæ¥å£è®¾è®¡](#9-apiæ¥å£è®¾è®¡) - è§ç¬¬3éƒ¨åˆ†
10. [å®ç°è®¡åˆ’](#10-å®ç°è®¡åˆ’) - è§ç¬¬3éƒ¨åˆ†

---

## 1. æ¨¡å—æ¦‚è¿°

### 1.1 åŠŸèƒ½å®šä½
å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—ç”¨äºåŸºäºå·²æ ‡å®šç³»æ•°çš„åº”åŠ›æµ‹é‡ï¼ŒåŒ…å«**å•ç‚¹å®æ—¶æ£€æµ‹**å’Œ**å¤šç‚¹åº”åŠ›åœºæµ‹ç»˜**ä¸¤å¤§åŠŸèƒ½ã€‚

### 1.2 æ ¸å¿ƒåŠŸèƒ½

#### å•ç‚¹å®æ—¶æ£€æµ‹ï¼ˆç°æœ‰åŠŸèƒ½ï¼‰
- åŠ è½½æ ‡å®šæ•°æ®
- é‡‡é›†åŸºå‡†æ³¢å½¢
- è®¢é˜…å®æ—¶é‡‡é›†æ¨¡å—çš„æ³¢å½¢æ˜¾ç¤º
- å®æ—¶è®¡ç®—åº”åŠ›å€¼
- è®°å½•å’Œå¯¼å‡ºæ£€æµ‹æ•°æ®

#### å¤šç‚¹åº”åŠ›åœºæµ‹ç»˜ï¼ˆæ–°å¢åŠŸèƒ½ï¼‰
- è¯•ä»¶å½¢çŠ¶å®šä¹‰ï¼ˆçŸ©å½¢ã€åœ†å½¢ã€è‡ªå®šä¹‰å¤šè¾¹å½¢ï¼‰
- æ™ºèƒ½å¸ƒç‚¹ï¼ˆç½‘æ ¼ã€æåæ ‡ã€å˜é—´è·ã€è‡ªå®šä¹‰ï¼‰
- é€ç‚¹é‡‡é›†æµ‹é‡
- å®æ—¶æ›´æ–°åº”åŠ›äº‘å›¾
- æ•°æ®è¡¨æ ¼ç®¡ç†å’Œå¯¼å‡º

### 1.3 åº”ç”¨åœºæ™¯
- **å•ç‚¹æ£€æµ‹**ï¼šå®æ—¶ç›‘æ§å•ç‚¹åº”åŠ›å˜åŒ–ã€è´¨é‡æ§åˆ¶ã€å¿«é€Ÿæ£€æµ‹
- **åº”åŠ›åœºæµ‹ç»˜**ï¼šå¹³æ¿åº”åŠ›åˆ†å¸ƒã€å­”æ´åº”åŠ›é›†ä¸­ã€å¤æ‚å½¢çŠ¶åº”åŠ›åœºç ”ç©¶

### 1.4 æŠ€æœ¯ä¾èµ–
- **å‰ç½®æ¨¡å—**ï¼šåº”åŠ›æ ‡å®šæ¨¡å—ï¼ˆå¿…é¡»å…ˆå®Œæˆæ ‡å®šï¼‰ã€å®æ—¶é‡‡é›†æ¨¡å—ï¼ˆå•ç‚¹æ£€æµ‹éœ€è¦ï¼‰
- **æ ¸å¿ƒç®—æ³•**ï¼šäº’ç›¸å…³æ—¶é—´å·®è®¡ç®—ã€scipy.interpolate.griddataï¼ˆæ’å€¼ï¼‰
- **æ•°æ®å­˜å‚¨**ï¼šSQLiteï¼ˆå…ƒæ•°æ®ï¼‰+ HDF5ï¼ˆæ³¢å½¢æ•°æ®ï¼‰
- **æ–°å¢ä¾èµ–**ï¼šshapelyï¼ˆå‡ ä½•è¿ç®—ï¼‰

---

## 2. ä»£ç æ¶æ„è®¾è®¡

### 2.1 åç«¯æ¶æ„

#### ç›®å½•ç»“æ„
```
modules/stress_detection_uniaxial/
â”œâ”€â”€ __init__.py                     # æ¨¡å—å¯¼å‡º
â”œâ”€â”€ field_experiment.py             # å®éªŒç®¡ç†ï¼ˆ200è¡Œï¼‰
â”œâ”€â”€ field_capture.py                # é‡‡é›†æ§åˆ¶ï¼ˆ250è¡Œï¼‰
â”œâ”€â”€ shape_utils.py                  # å½¢çŠ¶å·¥å…·ï¼ˆ200è¡Œï¼‰
â”œâ”€â”€ point_generator.py              # æµ‹ç‚¹ç”Ÿæˆï¼ˆ200è¡Œï¼‰
â”œâ”€â”€ interpolation.py                # æ’å€¼ç®—æ³•ï¼ˆ150è¡Œï¼‰
â””â”€â”€ contour_generator.py            # äº‘å›¾ç”Ÿæˆï¼ˆ150è¡Œï¼‰

è¯´æ˜:
- é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼Œæ¯ä¸ªæ–‡ä»¶èŒè´£å•ä¸€
- æ¯ä¸ªæ–‡ä»¶ 150-250 è¡Œï¼Œæ˜“äºç»´æŠ¤å’Œæµ‹è¯•
- å·¥å…·æ–‡ä»¶æä¾›çº¯å‡½æ•°ï¼Œä¸šåŠ¡æ–‡ä»¶ç®¡ç†çŠ¶æ€

æ€»è®¡ï¼š~1150è¡Œä»£ç 
```

#### æ¨¡å—èŒè´£è¯¦è§£

**field_experiment.py**ï¼ˆå®éªŒç®¡ç†ï¼Œ200è¡Œï¼‰
```python
class FieldExperiment:
    """åº”åŠ›åœºå®éªŒç®¡ç†"""
    
    def __init__(self, data_manager):
        """åˆå§‹åŒ–
        å‚æ•°: data_manager - æ•°æ®ç®¡ç†å™¨å®ä¾‹ï¼ˆä¸æ ‡å®šæ¨¡å—å…±ç”¨ï¼‰
        """
        self.dm = data_manager
    
    def create_experiment(self, name, description, calibration_data, shape_config) -> dict
        """åˆ›å»ºæ–°å®éªŒ
        å‚æ•°:
            name - å®éªŒåç§°
            description - å®éªŒæè¿°
            calibration_data - æ ‡å®šæ•°æ®ï¼ˆåº”åŠ›ç³»æ•°kï¼‰
            shape_config - è¯•ä»¶å½¢çŠ¶é…ç½®
        è¿”å›: {"success": bool, "exp_id": str, "message": str}
        """
    
    def load_calibration_from_experiment(self, calib_exp_id, direction) -> dict
        """ä»æœ¬åœ°æ ‡å®šå®éªŒåŠ è½½æ ‡å®šç³»æ•°
        
        å‚æ•°:
            calib_exp_id - æ ‡å®šå®éªŒIDï¼ˆå¦‚ 3 è¡¨ç¤º EXP003ï¼‰
            direction - æµ‹è¯•æ–¹å‘ï¼ˆå¦‚ "0Â°"ï¼‰
        
        è¿”å›: {"success": bool, "data": {...}}
        
        å®ç°åŸç†:
        1. é€šè¿‡ data_manager è®¿é—® experiments.db
        2. æŸ¥è¯¢ test_directions è¡¨è·å–æ–¹å‘ID
        3. æŸ¥è¯¢ fitting_results è¡¨è·å–æ‹Ÿåˆç»“æœ
        4. è®¡ç®—åº”åŠ›ç³»æ•° k = 1/æ–œç‡
        
        æ•°æ®åº“æŸ¥è¯¢:
            SELECT æ–œç‡, æˆªè·, Ræ–¹
            FROM fitting_results fr
            JOIN test_directions td ON fr.æ–¹å‘ID = td.id
            WHERE td.å®éªŒID = ? AND td.æ–¹å‘åç§° = ?
            ORDER BY fr.id DESC
            LIMIT 1
        
        è¿”å›æ•°æ®:
            {
                "k": float,              # åº”åŠ›ç³»æ•° (MPa/ns)
                "slope": float,          # åŸå§‹æ–œç‡ (ns/MPa)
                "intercept": float,      # æˆªè· (ns)
                "r_squared": float,      # æ‹Ÿåˆä¼˜åº¦
                "source": "local",
                "exp_id": calib_exp_id,
                "direction": direction
            }
        """
    
    def load_calibration_from_file(self, file_path) -> dict
        """ä»æ–‡ä»¶å¯¼å…¥æ ‡å®šæ•°æ®
        
        æ”¯æŒæ ¼å¼:
        - CSV: åŒ…å«åº”åŠ›-æ—¶é—´å·®æ•°æ®ï¼Œè‡ªåŠ¨æ‹Ÿåˆ
        - HDF5: ç›´æ¥è¯»å–æ‹Ÿåˆç»“æœ
        - JSON: ç›´æ¥è¯»å–åº”åŠ›ç³»æ•°
        
        è¿”å›: {"success": bool, "data": {"k": float, "source": "file", ...}}
        """
    
    def validate_calibration_data(self, calibration_data) -> dict
        """éªŒè¯æ ‡å®šæ•°æ®æœ‰æ•ˆæ€§
        
        æ£€æŸ¥é¡¹:
        - åº”åŠ›ç³»æ•° k æ˜¯å¦åˆç†ï¼ˆé€šå¸¸ 0.1-10 MPa/nsï¼‰
        - æ‹Ÿåˆä¼˜åº¦ RÂ² æ˜¯å¦è¶³å¤Ÿé«˜ï¼ˆå»ºè®® > 0.95ï¼‰
        - æ•°æ®æ¥æºæ˜¯å¦å¯é 
        
        è¿”å›: {"is_valid": bool, "warnings": list}
        """
    
    def load_experiment(self, exp_id) -> dict
        """åŠ è½½å·²æœ‰å®éªŒ
        è¿”å›: {"success": bool, "data": {...}, "message": str}
        åŒ…å«: å®éªŒé…ç½®ã€æµ‹ç‚¹åˆ—è¡¨ã€é‡‡é›†è¿›åº¦
        """
    
    def delete_experiment(self, exp_id) -> dict
        """åˆ é™¤å®éªŒ
        åŒæ—¶åˆ é™¤ SQLite è®°å½•å’Œ HDF5 æ–‡ä»¶
        """
    
    def export_experiment(self, exp_id, format, options) -> dict
        """å¯¼å‡ºå®éªŒæ•°æ®
        å‚æ•°:
            format - 'csv' | 'excel' | 'json'
            options - {"include_waveforms": bool, "include_contour": bool}
        è¿”å›: {"success": bool, "file_path": str}
        """
    
    def get_experiment_list(self, status_filter=None) -> list
        """è·å–å®éªŒåˆ—è¡¨
        å‚æ•°: status_filter - 'in_progress' | 'completed' | None
        è¿”å›: [{"exp_id": str, "name": str, "status": str, ...}, ...]
        """
    
    def update_experiment_status(self, exp_id, status) -> dict
        """æ›´æ–°å®éªŒçŠ¶æ€
        å‚æ•°: status - 'in_progress' | 'completed'
        """
    
    def get_experiment_statistics(self, exp_id) -> dict
        """è·å–å®éªŒç»Ÿè®¡ä¿¡æ¯
        è¿”å›: {"total_points": int, "completed": int, "skipped": int,
               "stress_range": [min, max], "avg_stress": float}
        """
    
    def get_calibration_experiment_list(self) -> list
        """è·å–å¯ç”¨çš„æ ‡å®šå®éªŒåˆ—è¡¨
        
        æŸ¥è¯¢æ‰€æœ‰å·²å®Œæˆæ ‡å®šçš„å®éªŒï¼Œä¾›ç”¨æˆ·é€‰æ‹©
        
        è¿”å›: [
            {
                "exp_id": int,
                "name": str,
                "material": str,
                "directions": ["0Â°", "45Â°", "90Â°"],
                "created_at": str
            },
            ...
        ]
        """
```

**field_capture.py**ï¼ˆé‡‡é›†æ§åˆ¶ï¼Œ250è¡Œï¼‰
```python
class FieldCapture:
    """æµ‹ç‚¹é‡‡é›†æ§åˆ¶"""
    
    def __init__(self, oscilloscope, data_manager, signal_processor):
        """åˆå§‹åŒ–
        å‚æ•°:
            oscilloscope - ç¤ºæ³¢å™¨å®ä¾‹
            data_manager - æ•°æ®ç®¡ç†å™¨å®ä¾‹
            signal_processor - ä¿¡å·å¤„ç†å™¨å®ä¾‹
        """
        self.osc = oscilloscope
        self.dm = data_manager
        self.sp = signal_processor
        self.denoise_config = self._get_default_denoise_config()
        self.baseline_waveform = None
        self.monitoring = False  # å®æ—¶ç›‘æ§çŠ¶æ€
    
    def start_monitoring(self) -> dict
        """å¼€å§‹å®æ—¶ç›‘æ§
        å‰ç«¯è®¢é˜…å®æ—¶é‡‡é›†æ¨¡å—çš„æ³¢å½¢æ›´æ–°ï¼Œæ˜¾ç¤ºNORMæ¨¡å¼æ³¢å½¢
        è¿”å›: {"success": bool, "message": str}
        """
    
    def stop_monitoring(self) -> dict
        """åœæ­¢å®æ—¶ç›‘æ§
        å‰ç«¯å–æ¶ˆè®¢é˜…
        è¿”å›: {"success": bool, "message": str}
        """
    
    def set_denoise_config(self, config) -> dict
        """è®¾ç½®é™å™ªå‚æ•°
        å‚æ•°: config - {"method": str, "wavelet": str, "level": int, 
                        "threshold_mode": str, "threshold_rule": str}
        è¿”å›: {"success": bool, "message": str}
        """
    
    def test_denoise_effect(self) -> dict
        """æµ‹è¯•é™å™ªæ•ˆæœ
        1. ä»ç¤ºæ³¢å™¨é‡‡é›†ä¸€æ¬¡RAWæ³¢å½¢
        2. åº”ç”¨å½“å‰é™å™ªå‚æ•°
        3. è®¡ç®—ä¿¡å™ªæ¯”æå‡
        è¿”å›: {"success": bool, "original_snr": float, "denoised_snr": float,
               "improvement": float, "waveforms": {...}}
        """
    
    def capture_point(self, exp_id, point_id, auto_denoise=True) -> dict
        """é‡‡é›†å•ä¸ªæµ‹ç‚¹
        æµç¨‹:
            1. ä»ç¤ºæ³¢å™¨é‡‡é›†RAWæ³¢å½¢ï¼ˆ12bitç²¾åº¦ï¼Œå®Œæ•´å­˜å‚¨æ·±åº¦ï¼‰
            2. åº”ç”¨é™å™ªï¼ˆå¦‚æœå¯ç”¨ï¼‰
            3. ä¸åŸºå‡†ç‚¹äº’ç›¸å…³
            4. è®¡ç®—æ—¶é—´å·®å’Œåº”åŠ›å€¼
            5. è¯„ä¼°æ³¢å½¢è´¨é‡
        å‚æ•°:
            exp_id - å®éªŒID
            point_id - æµ‹ç‚¹ID
            auto_denoise - æ˜¯å¦è‡ªåŠ¨é™å™ª
        è¿”å›: {"success": bool, "time_diff": float, "stress": float,
               "quality": str, "waveform": array, "message": str}
        """
    
    def save_point_data(self, exp_id, point_id, waveform, stress, time_diff) -> dict
        """ä¿å­˜æµ‹ç‚¹æ•°æ®
        1. ä¿å­˜æ³¢å½¢åˆ° HDF5: data/uniaxial_field/FIELD001/point_001.h5
        2. ä¿å­˜æµ‹é‡ç»“æœåˆ° SQLite: field_points è¡¨
        """
    
    def get_capture_progress(self, exp_id) -> dict
        """è·å–é‡‡é›†è¿›åº¦
        è¿”å›: {"total": int, "completed": int, "skipped": int,
               "current_point": int, "percentage": float}
        """
    
    def skip_point(self, exp_id, point_id, reason="") -> dict
        """è·³è¿‡æµ‹ç‚¹
        æ ‡è®°æµ‹ç‚¹ä¸º"å·²è·³è¿‡"çŠ¶æ€ï¼Œä¸å‚ä¸äº‘å›¾æ’å€¼
        """
    
    def recapture_point(self, exp_id, point_id) -> dict
        """é‡æ–°é‡‡é›†æµ‹ç‚¹
        è¦†ç›–å·²æœ‰æ•°æ®
        """
    
    def _get_default_denoise_config(self) -> dict
        """è·å–é»˜è®¤é™å™ªé…ç½®
        è¿”å›: {"method": "wavelet", "wavelet": "sym6", "level": 5,
               "threshold_mode": "soft", "threshold_rule": "heursure"}
        """
    
    def _evaluate_waveform_quality(self, waveform) -> str
        """è¯„ä¼°æ³¢å½¢è´¨é‡
        åŸºäºä¿¡å™ªæ¯”ã€å³°å€¼å¹…åº¦ç­‰æŒ‡æ ‡
        è¿”å›: 'excellent' | 'good' | 'fair' | 'poor'
        """
```

**shape_utils.py**ï¼ˆå½¢çŠ¶å·¥å…·ï¼Œ200è¡Œï¼‰
```python
# å½¢çŠ¶éªŒè¯
def validate_shape(shape_config) -> dict
    """éªŒè¯å½¢çŠ¶é…ç½®çš„æœ‰æ•ˆæ€§
    å‚æ•°: shape_config - {"type": str, "params": dict, "modifiers": list}
    è¿”å›: {"is_valid": bool, "area": float, "warnings": list}
    
    æ£€æŸ¥é¡¹:
    - å°ºå¯¸æ˜¯å¦åˆç†ï¼ˆ> 0ï¼‰
    - å­”æ´æ˜¯å¦åœ¨å½¢çŠ¶å†…
    - å¸ƒå°”è¿ç®—åæ˜¯å¦ä»æœ‰æœ‰æ•ˆåŒºåŸŸ
    """

# å½¢çŠ¶é®ç½©
def create_shape_mask(shape_config, resolution) -> np.ndarray
    """åˆ›å»ºå½¢çŠ¶é®ç½©ï¼ˆç”¨äºæ’å€¼æ—¶æ’é™¤æ— æ•ˆåŒºåŸŸï¼‰
    å‚æ•°: 
        shape_config - å½¢çŠ¶é…ç½®
        resolution - ç½‘æ ¼åˆ†è¾¨ç‡ (nx, ny)
    è¿”å›: å¸ƒå°”æ•°ç»„ (ny, nx)ï¼ŒTrueè¡¨ç¤ºæœ‰æ•ˆåŒºåŸŸ
    
    ç”¨é€”: æ’å€¼æ—¶åªåœ¨æœ‰æ•ˆåŒºåŸŸå†…è®¡ç®—ï¼Œå­”æ´åŒºåŸŸä¸æ’å€¼
    """

# ç‚¹ä½åˆ¤æ–­
def is_point_inside(x, y, shape_config) -> bool
    """åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å½¢çŠ¶å†…ï¼ˆè€ƒè™‘å­”æ´ï¼‰
    ç”¨äºå¸ƒç‚¹æ—¶è¿‡æ»¤æ— æ•ˆæµ‹ç‚¹
    
    ç®—æ³•: ä½¿ç”¨ shapely åº“çš„ contains æ–¹æ³•
    """

# é¢ç§¯è®¡ç®—
def calculate_shape_area(shape_config) -> float
    """è®¡ç®—å½¢çŠ¶é¢ç§¯ï¼ˆæ‰£é™¤å­”æ´ï¼‰
    ç”¨äºéªŒè¯æœ‰æ•ˆæµ‹é‡åŒºåŸŸæ˜¯å¦è¶³å¤Ÿ
    
    æœ€å°é¢ç§¯è¦æ±‚: 100 mmÂ²ï¼ˆè‡³å°‘èƒ½æ”¾3ä¸ªæµ‹ç‚¹ï¼‰
    """

# å¸ƒå°”è¿ç®—
def apply_boolean_operations(base_shape, modifiers) -> shapely.Polygon
    """åº”ç”¨å¸ƒå°”è¿ç®—ï¼ˆå­”æ´ã€ç¼ºå£ï¼‰
    å‚æ•°:
        base_shape - åŸºç¡€å½¢çŠ¶ï¼ˆçŸ©å½¢/åœ†å½¢/å¤šè¾¹å½¢ï¼‰
        modifiers - ä¿®æ”¹å™¨åˆ—è¡¨ [{"type": "hole", "shape": {...}}, ...]
    è¿”å›: shapely.Polygon å¯¹è±¡
    
    ä½¿ç”¨ shapely åº“è¿›è¡Œå‡ ä½•è¿ç®—:
    - å­”æ´: base_shape.difference(hole_shape)
    - ç¼ºå£: base_shape.difference(notch_shape)
    """
```

**point_generator.py**ï¼ˆæµ‹ç‚¹ç”Ÿæˆï¼Œ200è¡Œï¼‰
```python
# ç½‘æ ¼å¸ƒç‚¹
def generate_grid_points(shape_config, rows, cols, row_spacing, col_spacing, margins) -> list
    """ç”Ÿæˆå‡åŒ€ç½‘æ ¼æµ‹ç‚¹
    å‚æ•°:
        shape_config - å½¢çŠ¶é…ç½®
        rows, cols - è¡Œåˆ—æ•°
        row_spacing - è¡Œé—´è·ï¼ˆå¯ä»¥æ˜¯æ•°ç»„ï¼Œæ”¯æŒå˜é—´è·ï¼‰
        col_spacing - åˆ—é—´è·ï¼ˆå¯ä»¥æ˜¯æ•°ç»„ï¼Œæ”¯æŒå˜é—´è·ï¼‰
        margins - è¾¹è· {"top": float, "bottom": float, "left": float, "right": float}
    è¿”å›: [{"id": int, "x": float, "y": float}, ...]
    
    ç®—æ³•:
    1. è®¡ç®—æµ‹ç‚¹åŒºåŸŸï¼ˆæ‰£é™¤è¾¹è·ï¼‰
    2. æ ¹æ®è¡Œåˆ—æ•°å’Œé—´è·ç”Ÿæˆç½‘æ ¼
    3. è¿‡æ»¤æ‰å½¢çŠ¶å¤–çš„ç‚¹ï¼ˆä½¿ç”¨ is_point_insideï¼‰
    """

# æåæ ‡å¸ƒç‚¹
def generate_polar_points(center, r_start, r_end, n_rings, angle_range, points_per_ring) -> list
    """ç”Ÿæˆæåæ ‡æµ‹ç‚¹ï¼ˆåœ†ç¯ + ç­‰è§’åº¦åˆ†å¸ƒï¼‰
    å‚æ•°:
        center - åœ†å¿ƒåæ ‡ (x, y)
        r_start, r_end - èµ·å§‹/ç»“æŸåŠå¾„
        n_rings - å¾„å‘å±‚æ•°
        angle_range - è§’åº¦èŒƒå›´ (start_deg, end_deg)
        points_per_ring - æ¯å±‚ç‚¹æ•°ï¼ˆå¯ä»¥æ˜¯æ•°ç»„ï¼Œæ”¯æŒæ¯å±‚ä¸åŒï¼‰
    è¿”å›: [{"id": int, "x": float, "y": float, "r": float, "theta": float}, ...]
    
    é€‚ç”¨äº: åœ†å½¢è¯•ä»¶ã€å­”æ´å‘¨å›´åº”åŠ›é›†ä¸­åŒºåŸŸ
    """

# å˜é—´è·å¸ƒç‚¹
def generate_adaptive_points(shape_config, dense_region, n_dense, n_sparse) -> list
    """ç”Ÿæˆå˜é—´è·æµ‹ç‚¹ï¼ˆåº”åŠ›é›†ä¸­åŒºåŸŸåŠ å¯†ï¼‰
    å‚æ•°:
        shape_config - å½¢çŠ¶é…ç½®
        dense_region - å¯†é›†åŒºåŸŸ {"center": (x, y), "radius": float}
        n_dense - å¯†é›†åŒºæµ‹ç‚¹æ•°
        n_sparse - å¤–å›´æµ‹ç‚¹æ•°
    è¿”å›: [{"id": int, "x": float, "y": float}, ...]
    
    ç®—æ³•:
    1. åœ¨å¯†é›†åŒºåŸŸå†…ç”Ÿæˆ n_dense ä¸ªéšæœºç‚¹ï¼ˆæˆ–å°ç½‘æ ¼ï¼‰
    2. åœ¨å¤–å›´åŒºåŸŸç”Ÿæˆ n_sparse ä¸ªå‡åŒ€ç‚¹
    3. åˆå¹¶å¹¶ä¼˜åŒ–é¡ºåº
    """

# è‡ªå®šä¹‰å¸ƒç‚¹
def load_custom_points(file_path) -> list
    """ä»CSVæ–‡ä»¶åŠ è½½è‡ªå®šä¹‰æµ‹ç‚¹
    CSVæ ¼å¼: id,x,y
    """

# é¡ºåºä¼˜åŒ–
def optimize_point_order(points, strategy='zigzag') -> list
    """ä¼˜åŒ–æµ‹ç‚¹é¡ºåºï¼Œå‡å°‘æ¢å¤´ç§»åŠ¨è·ç¦»
    ç­–ç•¥:
        - 'zigzag': ä¹‹å­—å½¢æ‰«æï¼ˆé€‚åˆç½‘æ ¼ï¼‰
        - 'nearest': æœ€è¿‘é‚»ç®—æ³•ï¼ˆé€‚åˆä¸è§„åˆ™å¸ƒç‚¹ï¼‰
        - 'spiral': èºæ—‹æ‰«æï¼ˆé€‚åˆæåæ ‡ï¼‰
    è¿”å›: é‡æ–°æ’åºçš„æµ‹ç‚¹åˆ—è¡¨
    """
```

**interpolation.py**ï¼ˆæ’å€¼ç®—æ³•ï¼Œ150è¡Œï¼‰
```python
# åº”åŠ›åœºæ’å€¼
def interpolate_stress_field(points, shape_config, method='cubic', resolution=100) -> dict
    """æ’å€¼ç”Ÿæˆåº”åŠ›åœº
    å‚æ•°:
        points - å·²æµ‹ç‚¹æ•°æ® [{"x": float, "y": float, "stress": float}, ...]
        shape_config - å½¢çŠ¶é…ç½®ï¼ˆç”¨äºç”Ÿæˆé®ç½©ï¼‰
        method - 'linear' | 'cubic' | 'rbf'ï¼ˆå¾„å‘åŸºå‡½æ•°ï¼‰
        resolution - ç½‘æ ¼å¯†åº¦ï¼ˆæ¯è¾¹ç‚¹æ•°ï¼‰
    è¿”å›: {"xi": array, "yi": array, "zi": array, "mask": array}
    
    ç®—æ³•:
    1. ä½¿ç”¨ scipy.interpolate.griddata è¿›è¡Œæ’å€¼
    2. åº”ç”¨å½¢çŠ¶é®ç½©ï¼Œå­”æ´åŒºåŸŸè®¾ä¸º NaN
    3. è¿”å›æ’å€¼ç½‘æ ¼æ•°æ®
    """

# ç½®ä¿¡åº¦è¯„ä¼°
def get_confidence_level(n_points, shape_area) -> str
    """æ ¹æ®æµ‹ç‚¹æ•°å’Œé¢ç§¯è¿”å›ç½®ä¿¡åº¦ç­‰çº§
    è§„åˆ™:
        - < 3 ç‚¹: 'insufficient'ï¼ˆä¸è¶³ï¼Œæ— æ³•æ’å€¼ï¼‰
        - 3-8 ç‚¹: 'preview'ï¼ˆé¢„è§ˆï¼Œä»…ä¾›å‚è€ƒï¼‰
        - >= 9 ç‚¹: 'full'ï¼ˆå®Œæ•´ï¼Œå¯ä¿¡åº¦é«˜ï¼‰
        - å¯†åº¦ > 1ç‚¹/100mmÂ²: 'high_density'ï¼ˆé«˜å¯†åº¦ï¼‰
    """

# ç­‰é«˜çº¿ç”Ÿæˆ
def generate_contour_lines(xi, yi, zi, levels=10) -> list
    """ç”Ÿæˆç­‰é«˜çº¿æ•°æ®
    å‚æ•°:
        xi, yi, zi - æ’å€¼ç½‘æ ¼æ•°æ®
        levels - ç­‰é«˜çº¿å±‚æ•°
    è¿”å›: [{"level": float, "paths": [[(x, y), ...], ...]}, ...]
    
    ä½¿ç”¨ matplotlib.pyplot.contour ç”Ÿæˆç­‰é«˜çº¿
    """
```

**contour_generator.py**ï¼ˆäº‘å›¾ç”Ÿæˆï¼Œ150è¡Œï¼‰
```python
class ContourGenerator:
    """åº”åŠ›äº‘å›¾ç”Ÿæˆ"""
    
    def __init__(self):
        self.colormap_options = ['jet', 'rainbow', 'viridis', 'coolwarm']
    
    def generate_contour(self, points, shape_config, method='cubic', resolution=50, 
                        vmin=None, vmax=None, colormap='jet') -> dict
        """ç”Ÿæˆäº‘å›¾æ•°æ®
        æµç¨‹:
        1. è°ƒç”¨ interpolate_stress_field æ’å€¼
        2. åº”ç”¨å½¢çŠ¶é®ç½©
        3. ç”Ÿæˆç­‰é«˜çº¿
        4. ç”Ÿæˆè‰²æ ‡æ˜ å°„
        5. è¿”å›å¯è§†åŒ–æ•°æ®
        
        è¿”å›: {"xi": array, "yi": array, "zi": array, "mask": array,
               "contour_lines": list, "colormap": str, "vmin": float, "vmax": float}
        """
    
    def get_color_map(self, stress_values, vmin, vmax, colormap='jet') -> dict
        """ç”Ÿæˆè‰²æ ‡æ˜ å°„
        å‚æ•°:
            stress_values - åº”åŠ›å€¼æ•°ç»„
            vmin, vmax - è‰²æ ‡èŒƒå›´ï¼ˆNoneè¡¨ç¤ºè‡ªåŠ¨ï¼‰
            colormap - è‰²å›¾åç§°
        è¿”å›: {"colors": array, "levels": array, "colormap": str}
        """
    
    def export_contour_image(self, contour_data, shape_config, file_path, dpi=300) -> dict
        """å¯¼å‡ºäº‘å›¾ä¸ºå›¾ç‰‡
        ä½¿ç”¨ matplotlib ç»˜åˆ¶å¹¶ä¿å­˜ä¸º PNG
        åŒ…å«: è¯•ä»¶è½®å»“ã€æµ‹ç‚¹ä½ç½®ã€åº”åŠ›äº‘å›¾ã€è‰²æ ‡ã€æ ‡é¢˜
        """
    
    def update_contour_realtime(self, exp_id, new_point_data) -> dict
        """å®æ—¶æ›´æ–°äº‘å›¾ï¼ˆå¢é‡æ›´æ–°ï¼‰
        å½“æ–°é‡‡é›†ä¸€ä¸ªæµ‹ç‚¹åï¼Œé‡æ–°æ’å€¼å¹¶æ›´æ–°äº‘å›¾
        ä¼˜åŒ–: åªåœ¨æµ‹ç‚¹æ•° >= 3 æ—¶æ‰æ’å€¼
        """
```

# æ•°æ®å°è£…
def create_contour_data(xi, yi, zi) -> dict
    """åˆ›å»ºäº‘å›¾æ•°æ®ç»“æ„ï¼ˆä¾›å‰ç«¯ä½¿ç”¨ï¼‰
    åŒ…å«ç½‘æ ¼æ•°æ®ã€å…ƒæ•°æ®ã€ç½®ä¿¡åº¦ä¿¡æ¯
    """
```

---

### 2.2 å‰ç«¯æ¶æ„

#### ç›®å½•ç»“æ„
```
static/js/stress-detection-uniaxial/
â”œâ”€â”€ stress-detection-uniaxial.js    # ä¸»æ¨¡å—ï¼ˆ200è¡Œï¼‰
â”œâ”€â”€ field-experiment-manager.js     # å®éªŒç®¡ç†UIï¼ˆ200è¡Œï¼‰
â”œâ”€â”€ field-calibration-panel.js      # æ ‡å®šæ•°æ®é¢æ¿ï¼ˆ150è¡Œï¼‰
â”œâ”€â”€ field-shape-panel.js            # å½¢çŠ¶å®šä¹‰é¢æ¿ï¼ˆ200è¡Œï¼‰
â”œâ”€â”€ field-layout-panel.js           # å¸ƒç‚¹è®¾ç½®é¢æ¿ï¼ˆ200è¡Œï¼‰
â”œâ”€â”€ field-capture-panel.js          # é‡‡é›†æ§åˆ¶é¢æ¿ï¼ˆ250è¡Œï¼‰
â”œâ”€â”€ field-canvas.js                 # é¢„è§ˆç”»å¸ƒï¼ˆ200è¡Œï¼‰
â””â”€â”€ field-contour.js                # äº‘å›¾æ˜¾ç¤ºï¼ˆ200è¡Œï¼‰

è¯´æ˜:
- é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼Œæ¯ä¸ªæ–‡ä»¶å¯¹åº”ä¸€ä¸ªUIé¢æ¿æˆ–åŠŸèƒ½
- æ¯ä¸ªæ–‡ä»¶ 150-250 è¡Œï¼ŒèŒè´£å•ä¸€
- ä½¿ç”¨ IIFE æ¨¡å¼å°è£…ï¼Œé¿å…å…¨å±€å‘½åç©ºé—´æ±¡æŸ“

æ€»è®¡ï¼š~1600è¡Œä»£ç 
```

#### æ¨¡å—èŒè´£è¯¦è§£

**stress-detection-uniaxial.js**ï¼ˆä¸»æ¨¡å—ï¼Œ200è¡Œï¼‰
```javascript
const StressDetectionUniaxial = (function() {
    /**
     * ä¸»æ¨¡å—ï¼šæ ‡ç­¾é¡µåˆ‡æ¢ã€çŠ¶æ€ç®¡ç†ã€æ¨¡å—åè°ƒ
     */
    
    // çŠ¶æ€ç®¡ç†
    let currentTab = 'single-point';  // 'single-point' | 'field-mapping'
    let currentExperiment = null;
    
    // åˆå§‹åŒ–
    function init() {
        setupTabs();
        initSubModules();
        bindEvents();
    }
    
    // åˆå§‹åŒ–å­æ¨¡å—
    function initSubModules() {
        FieldExperimentManager.init();
        FieldCalibrationPanel.init();
        FieldShapePanel.init();
        FieldLayoutPanel.init();
        FieldCapturePanel.init();
        FieldCanvas.init();
        FieldContour.init();
    }
    
    // æ ‡ç­¾é¡µåˆ‡æ¢
    function switchTab(tab) {
        currentTab = tab;
        if (tab === 'single-point') {
            showSinglePointUI();
        } else {
            showFieldMappingUI();
        }
    }
    
    // è·å–å½“å‰å®éªŒ
    function getCurrentExperiment() {
        return currentExperiment;
    }
    
    // è®¾ç½®å½“å‰å®éªŒ
    function setCurrentExperiment(exp) {
        currentExperiment = exp;
        notifyExperimentChange(exp);
    }
    
    // é€šçŸ¥æ‰€æœ‰å­æ¨¡å—å®éªŒå·²åˆ‡æ¢
    function notifyExperimentChange(exp) {
        FieldCalibrationPanel.onExperimentChange(exp);
        FieldShapePanel.onExperimentChange(exp);
        FieldLayoutPanel.onExperimentChange(exp);
        FieldCapturePanel.onExperimentChange(exp);
        FieldCanvas.onExperimentChange(exp);
        FieldContour.onExperimentChange(exp);
    }
    
    return { 
        init, 
        switchTab, 
        getCurrentExperiment, 
        setCurrentExperiment 
    };
})();
```

**field-experiment-manager.js**ï¼ˆå®éªŒç®¡ç†UIï¼Œ200è¡Œï¼‰
```javascript
const FieldExperimentManager = (function() {
    /**
     * å®éªŒç®¡ç†ï¼šæ–°å»ºã€åŠ è½½ã€å¯¼å‡ºã€åˆ é™¤å®éªŒ
     */
    
    // åˆå§‹åŒ–
    function init() {
        bindButtons();
        updateExperimentInfo();
    }
    
    // æ–°å»ºå®éªŒ
    async function createExperiment() {
        const dialog = showCreateDialog();
        const result = await dialog.waitForInput();
        if (result.confirmed) {
            const response = await pywebview.api.create_field_experiment(
                result.name, result.description
            );
            if (response.success) {
                StressDetectionUniaxial.setCurrentExperiment(response.data);
                showToast('âœ“ å®éªŒåˆ›å»ºæˆåŠŸ', 'success');
            }
        }
    }
    
    // æ‰“å¼€å®éªŒç®¡ç†å¯¹è¯æ¡†
    function openExperimentManager() {
        const dialog = showExperimentListDialog();
        // æ˜¾ç¤ºå®éªŒåˆ—è¡¨ï¼Œæ”¯æŒåŠ è½½ã€å¯¼å‡ºã€åˆ é™¤æ“ä½œ
    }
    
    // å®Œæˆå®éªŒ
    async function completeExperiment() {
        const confirmed = await showConfirmDialog({
            title: 'å®Œæˆå®éªŒï¼Ÿ',
            message: 'å®éªŒå°†æ ‡è®°ä¸ºå·²å®ŒæˆçŠ¶æ€ï¼Œç¡®è®¤å—ï¼Ÿ'
        });
        if (confirmed) {
            await pywebview.api.complete_field_experiment(exp_id);
            showToast('âœ“ å®éªŒå·²å®Œæˆ', 'success');
        }
    }
    
    // æ›´æ–°å®éªŒä¿¡æ¯æ˜¾ç¤º
    function updateExperimentInfo() {
        const exp = StressDetectionUniaxial.getCurrentExperiment();
        if (exp) {
            document.querySelector('.exp-name').textContent = exp.name;
            document.querySelector('.exp-status').textContent = exp.status;
            document.querySelector('.exp-progress').textContent = 
                `${exp.completed}/${exp.total}`;
        }
    }
    
    return { init, createExperiment, openExperimentManager, completeExperiment };
})();
```

**field-calibration-panel.js**ï¼ˆæ ‡å®šæ•°æ®é¢æ¿ï¼Œ150è¡Œï¼‰
```javascript
const FieldCalibrationPanel = (function() {
    /**
     * æ ‡å®šæ•°æ®é€‰æ‹©ï¼š4ç§æ•°æ®æ¥æºçš„åŠ¨æ€UI
     */
    
    let currentSource = 'local';  // 'local' | 'file' | 'manual' | 'library'
    
    // åˆå§‹åŒ–
    function init() {
        bindSourceRadios();
        bindLoadButtons();
    }
    
    // åˆ‡æ¢æ•°æ®æ¥æº
    function switchSource(source) {
        currentSource = source;
        // éšè—æ‰€æœ‰å†…å®¹åŒº
        document.querySelectorAll('.calibration-content').forEach(el => {
            el.style.display = 'none';
        });
        // æ˜¾ç¤ºé€‰ä¸­çš„å†…å®¹åŒº
        document.querySelector(`.calibration-${source}`).style.display = 'block';
    }
    
    // ä»æœ¬åœ°å®éªŒåŠ è½½
    async function loadFromLocal() {
        const expId = document.querySelector('#calib-exp-select').value;
        const direction = document.querySelector('#calib-direction-select').value;
        const response = await pywebview.api.load_calibration_from_experiment(
            expId, direction
        );
        if (response.success) {
            updateCalibrationInfo(response.data);
        }
    }
    
    // ä»æ–‡ä»¶å¯¼å…¥
    async function loadFromFile() {
        const file = await selectFile('.json,.csv');
        const response = await pywebview.api.load_calibration_from_file(file);
        if (response.success) {
            updateCalibrationInfo(response.data);
        }
    }
    
    // æ‰‹åŠ¨è¾“å…¥
    function loadFromManual() {
        const k = parseFloat(document.querySelector('#manual-k').value);
        updateCalibrationInfo({ k, source: 'manual' });
    }
    
    // ä»ææ–™åº“é€‰æ‹©
    function loadFromLibrary() {
        const material = document.querySelector('#material-select').value;
        const k = getMaterialK(material);
        updateCalibrationInfo({ k, source: 'library', material });
    }
    
    // æ›´æ–°æ ‡å®šä¿¡æ¯æ˜¾ç¤º
    function updateCalibrationInfo(data) {
        document.querySelector('.calib-info').innerHTML = `
            âœ“ å·²åŠ è½½ä¿¡æ¯:<br>
            åº”åŠ›ç³»æ•° k: ${data.k} MPa/ns<br>
            æ¥æº: ${data.source}
        `;
    }
    
    return { init, switchSource };
})();
```

**field-shape-panel.js**ï¼ˆå½¢çŠ¶å®šä¹‰é¢æ¿ï¼Œ200è¡Œï¼‰
```javascript
const FieldShapePanel = (function() {
    /**
     * å½¢çŠ¶å®šä¹‰ï¼šçŸ©å½¢ã€åœ†å½¢ã€è‡ªå®šä¹‰ï¼Œå¸ƒå°”è¿ç®—
     */
    
    let shapeConfig = null;
    let booleanEnabled = false;
    
    // åˆå§‹åŒ–
    function init() {
        bindShapeTypeRadios();
        bindBooleanCheckbox();
        bindValidateButton();
    }
    
    // åˆ‡æ¢å½¢çŠ¶ç±»å‹
    function switchShapeType(type) {
        // æ˜¾ç¤ºå¯¹åº”çš„å‚æ•°è¾“å…¥åŒº
        document.querySelectorAll('.shape-params').forEach(el => {
            el.style.display = 'none';
        });
        document.querySelector(`.shape-${type}`).style.display = 'block';
    }
    
    // å¯ç”¨/ç¦ç”¨å¸ƒå°”è¿ç®—
    function toggleBoolean(enabled) {
        booleanEnabled = enabled;
        const controls = document.querySelector('.boolean-controls');
        const list = document.querySelector('.boolean-list');
        controls.style.display = enabled ? 'block' : 'none';
        list.style.display = enabled ? 'block' : 'none';
    }
    
    // æ·»åŠ å­”æ´
    function addHole() {
        const dialog = showAddHoleDialog();
        // ç”¨æˆ·è¾“å…¥å­”æ´å‚æ•°
    }
    
    // æ·»åŠ ç¼ºå£
    function addNotch() {
        const dialog = showAddNotchDialog();
        // ç”¨æˆ·è¾“å…¥ç¼ºå£å‚æ•°
    }
    
    // éªŒè¯å½¢çŠ¶
    async function validateShape() {
        shapeConfig = collectShapeConfig();
        const response = await pywebview.api.validate_shape(shapeConfig);
        if (response.success) {
            showToast(`âœ“ å½¢çŠ¶æœ‰æ•ˆ: é¢ç§¯ ${response.area} mmÂ²`, 'success');
            FieldCanvas.drawShape(shapeConfig);
        } else {
            showToast(`âŒ å½¢çŠ¶æ— æ•ˆ: ${response.message}`, 'error');
        }
    }
    
    // æ”¶é›†å½¢çŠ¶é…ç½®
    function collectShapeConfig() {
        const type = document.querySelector('input[name="shape-type"]:checked').value;
        // æ ¹æ®ç±»å‹æ”¶é›†å‚æ•°
        return { type, params: {...}, modifiers: [...] };
    }
    
    return { init, validateShape };
})();
```

**field-layout-panel.js**ï¼ˆå¸ƒç‚¹è®¾ç½®é¢æ¿ï¼Œ200è¡Œï¼‰
```javascript
const FieldLayoutPanel = (function() {
    /**
     * å¸ƒç‚¹è®¾ç½®ï¼šç½‘æ ¼ã€æåæ ‡ã€å˜é—´è·ã€è‡ªå®šä¹‰
     */
    
    let layoutType = 'grid';
    let points = [];
    
    // åˆå§‹åŒ–
    function init() {
        bindLayoutTypeSelect();
        bindGenerateButton();
        bindOptimizeButton();
    }
    
    // åˆ‡æ¢å¸ƒç‚¹æ–¹å¼
    function switchLayoutType(type) {
        layoutType = type;
        // æ˜¾ç¤ºå¯¹åº”çš„å‚æ•°è¾“å…¥åŒº
        document.querySelectorAll('.layout-params').forEach(el => {
            el.style.display = 'none';
        });
        document.querySelector(`.layout-${type}`).style.display = 'block';
    }
    
    // ç”Ÿæˆæµ‹ç‚¹
    async function generatePoints() {
        const params = collectLayoutParams();
        const shapeConfig = FieldShapePanel.getShapeConfig();
        const response = await pywebview.api.generate_point_layout(
            shapeConfig, layoutType, params
        );
        if (response.success) {
            points = response.data.points;
            showToast(`âœ“ å·²ç”Ÿæˆ ${points.length} ä¸ªæµ‹ç‚¹`, 'success');
            FieldCanvas.drawPoints(points);
            updatePointCount(points.length);
        }
    }
    
    // ä¼˜åŒ–é¡ºåº
    async function optimizeOrder() {
        const strategy = document.querySelector('#optimize-strategy').value;
        const response = await pywebview.api.optimize_point_order(points, strategy);
        if (response.success) {
            points = response.data.points;
            showToast('âœ“ é¡ºåºå·²ä¼˜åŒ–', 'success');
            FieldCanvas.drawPoints(points);
        }
    }
    
    // æ”¶é›†å¸ƒç‚¹å‚æ•°
    function collectLayoutParams() {
        if (layoutType === 'grid') {
            return {
                rows: parseInt(document.querySelector('#grid-rows').value),
                cols: parseInt(document.querySelector('#grid-cols').value),
                // ...
            };
        }
        // å…¶ä»–å¸ƒç‚¹æ–¹å¼...
    }
    
    return { init, generatePoints, getPoints: () => points };
})();
```

**field-capture-panel.js**ï¼ˆé‡‡é›†æ§åˆ¶é¢æ¿ï¼Œ250è¡Œï¼‰
```javascript
const FieldCapturePanel = (function() {
    /**
     * é‡‡é›†æ§åˆ¶ï¼šå®æ—¶ç›‘æ§ã€æµ‹ç‚¹é‡‡é›†ã€é™å™ªè®¾ç½®ã€è¿›åº¦ç®¡ç†
     */
    
    let captureState = 'waiting';  // 'waiting' | 'capturing' | 'confirming'
    let monitoringState = false;   // å®æ—¶ç›‘æ§çŠ¶æ€
    let currentPointIndex = 0;
    let denoiseConfig = null;
    
    // åˆå§‹åŒ–
    function init() {
        bindMonitorButtons();
        bindCaptureButton();
        bindConfirmButton();
        bindDenoiseButton();
        loadDefaultDenoiseConfig();
    }
    
    // å¼€å§‹å®æ—¶ç›‘æ§
    function startMonitoring() {
        if (!RealtimeCapture.è·å–è¿æ¥çŠ¶æ€()) {
            showToast('è¯·å…ˆè¿æ¥ç¤ºæ³¢å™¨', 'warning');
            return;
        }
        
        monitoringState = true;
        updateMonitorUI();
        
        // è®¢é˜…å®æ—¶é‡‡é›†æ¨¡å—çš„æ³¢å½¢æ›´æ–°ï¼ˆNORMæ¨¡å¼ï¼Œå¿«é€Ÿåˆ·æ–°ï¼‰
        RealtimeCapture.è®¢é˜…æ³¢å½¢æ›´æ–°(handleWaveformUpdate);
    }
    
    // åœæ­¢å®æ—¶ç›‘æ§
    function stopMonitoring() {
        monitoringState = false;
        updateMonitorUI();
        
        // å–æ¶ˆè®¢é˜…
        RealtimeCapture.å–æ¶ˆè®¢é˜…æ³¢å½¢æ›´æ–°(handleWaveformUpdate);
    }
    
    // å¤„ç†æ³¢å½¢æ›´æ–°ï¼ˆè®¢é˜…å›è°ƒï¼‰
    function handleWaveformUpdate(data) {
        if (!monitoringState) return;
        
        const { æ³¢å½¢æ•°æ®, æ˜¾ç¤ºçŠ¶æ€ } = data;
        
        // åœ¨å³ä¸Šè§’"å½“å‰æ³¢å½¢"åŒºåŸŸæ˜¾ç¤ºå®æ—¶æ³¢å½¢
        FieldCanvas.drawWaveform(æ³¢å½¢æ•°æ®, æ˜¾ç¤ºçŠ¶æ€);
    }
    
    // é‡‡é›†å½“å‰æµ‹ç‚¹
    async function captureCurrentPoint() {
        captureState = 'capturing';
        updateUI();
        
        const points = FieldLayoutPanel.getPoints();
        const point = points[currentPointIndex];
        
        // æš‚åœå®æ—¶ç›‘æ§æ˜¾ç¤º
        const wasMonitoring = monitoringState;
        if (wasMonitoring) {
            // ä¸å–æ¶ˆè®¢é˜…ï¼Œåªæ˜¯æ ‡è®°çŠ¶æ€
            monitoringState = false;
        }
        
        // è·å–RAWæ¨¡å¼é«˜ç²¾åº¦æ³¢å½¢ï¼ˆ12bitï¼Œå®Œæ•´å­˜å‚¨æ·±åº¦ï¼‰
        const rawResult = await RealtimeCapture.è·å–å½“å‰RAWæ³¢å½¢();
        
        if (!rawResult.success) {
            captureState = 'waiting';
            if (wasMonitoring) monitoringState = true;
            showToast(`é‡‡é›†å¤±è´¥: ${rawResult.message}`, 'error');
            updateUI();
            return;
        }
        
        // è°ƒç”¨åç«¯é‡‡é›†æ¥å£ï¼ˆåŒ…å«é™å™ªã€äº’ç›¸å…³ã€åº”åŠ›è®¡ç®—ï¼‰
        const response = await pywebview.api.capture_field_point(
            exp_id, point.id, denoiseConfig
        );
        
        if (response.success) {
            captureState = 'confirming';
            displayCaptureResult(response.data);
            
            // æ˜¾ç¤ºé‡‡é›†çš„æ³¢å½¢ï¼ˆè¦†ç›–å®æ—¶æ³¢å½¢ï¼‰
            FieldCanvas.drawWaveform(response.data.waveform);
        } else {
            captureState = 'waiting';
            if (wasMonitoring) monitoringState = true;
            showToast(`é‡‡é›†å¤±è´¥: ${response.message}`, 'error');
        }
        updateUI();
    }
    
    // ç¡®è®¤å¹¶ç»§ç»­
    async function confirmAndContinue() {
        await pywebview.api.save_point_data(exp_id, point_id, waveform, stress);
        currentPointIndex++;
        captureState = 'waiting';
        
        // æ¢å¤å®æ—¶ç›‘æ§
        monitoringState = true;
        
        updateProgress();
        updateUI();
        
        if (currentPointIndex < points.length) {
            showToast('å·²ä¿å­˜ï¼Œè¯·ç§»åŠ¨åˆ°ä¸‹ä¸€æµ‹ç‚¹', 'success');
        } else {
            showToast('æ‰€æœ‰æµ‹ç‚¹é‡‡é›†å®Œæˆï¼', 'success');
        }
    }
    
    // é‡æ–°é‡‡é›†
    function recapture() {
        captureState = 'waiting';
        
        // æ¢å¤å®æ—¶ç›‘æ§
        monitoringState = true;
        
        updateUI();
    }
    
    // æ‰“å¼€é™å™ªè®¾ç½®å¯¹è¯æ¡†
    function openDenoiseSettings() {
        const dialog = showDenoiseDialog(denoiseConfig);
        // ç”¨æˆ·é…ç½®é™å™ªå‚æ•°
        // æ”¯æŒæµ‹è¯•æ•ˆæœåŠŸèƒ½
    }
    
    // æµ‹è¯•é™å™ªæ•ˆæœ
    async function testDenoiseEffect(config) {
        const response = await pywebview.api.test_denoise_effect(config);
        if (response.success) {
            displayDenoiseComparison(response.data);
        }
    }
    
    // æ›´æ–°UIçŠ¶æ€
    function updateUI() {
        const buttons = {
            startMonitor: document.querySelector('#btn-start-monitor'),
            stopMonitor: document.querySelector('#btn-stop-monitor'),
            capture: document.querySelector('#btn-capture'),
            confirm: document.querySelector('#btn-confirm'),
            recapture: document.querySelector('#btn-recapture')
        };
        
        // ç›‘æ§æŒ‰é’®
        buttons.startMonitor.style.display = monitoringState ? 'none' : 'inline-block';
        buttons.stopMonitor.style.display = monitoringState ? 'inline-block' : 'none';
        
        // é‡‡é›†æŒ‰é’®
        if (captureState === 'waiting') {
            buttons.capture.disabled = false;
            buttons.confirm.disabled = true;
            buttons.recapture.disabled = true;
        } else if (captureState === 'capturing') {
            buttons.capture.disabled = true;
            buttons.confirm.disabled = true;
            buttons.recapture.disabled = true;
        } else if (captureState === 'confirming') {
            buttons.capture.disabled = true;
            buttons.confirm.disabled = false;
            buttons.recapture.disabled = false;
        }
    }
    
    return { init, captureCurrentPoint, startMonitoring, stopMonitoring };
})();
```

**field-canvas.js**ï¼ˆé¢„è§ˆç”»å¸ƒï¼Œ200è¡Œï¼‰
```javascript
const FieldCanvas = (function() {
    /**
     * é¢„è§ˆç”»å¸ƒï¼šæ˜¾ç¤ºè¯•ä»¶å½¢çŠ¶ã€æµ‹ç‚¹å¸ƒå±€ã€ç½‘æ ¼
     */
    
    let canvas, ctx;
    let shapeConfig = null;
    let points = [];
    let showGrid = true;
    let showScale = true;
    
    // åˆå§‹åŒ–
    function init() {
        canvas = document.querySelector('#field-preview-canvas');
        ctx = canvas.getContext('2d');
        bindControlPanel();
    }
    
    // ç»˜åˆ¶å½¢çŠ¶
    function drawShape(config) {
        shapeConfig = config;
        redraw();
    }
    
    // ç»˜åˆ¶æµ‹ç‚¹
    function drawPoints(pts) {
        points = pts;
        redraw();
    }
    
    // é‡ç»˜ç”»å¸ƒ
    function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (showGrid) drawGridLines();
        if (shapeConfig) drawShapeOutline();
        if (points.length > 0) drawPointMarkers();
    }
    
    // ç»˜åˆ¶ç½‘æ ¼çº¿
    function drawGridLines() {
        ctx.strokeStyle = '#E0E0E0';
        ctx.lineWidth = 1;
        // ç»˜åˆ¶ç½‘æ ¼...
    }
    
    // ç»˜åˆ¶å½¢çŠ¶è½®å»“
    function drawShapeOutline() {
        ctx.strokeStyle = '#2196F3';
        ctx.lineWidth = 2;
        ctx.fillStyle = 'rgba(100, 150, 255, 0.1)';
        // æ ¹æ®å½¢çŠ¶ç±»å‹ç»˜åˆ¶...
    }
    
    // ç»˜åˆ¶æµ‹ç‚¹æ ‡è®°
    function drawPointMarkers() {
        points.forEach(point => {
            const status = point.status || 'pending';
            
            // ç»˜åˆ¶åœ†ç‚¹
            ctx.fillStyle = getPointColor(status);
            ctx.beginPath();
            ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);
            ctx.fill();
            
            // ç»˜åˆ¶æµ‹ç‚¹ç¼–å·
            ctx.fillStyle = '#212121';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(`#${point.id}`, point.x, point.y - 6);
        });
    }
    
    // è·å–æµ‹ç‚¹é¢œè‰²
    function getPointColor(status) {
        const colors = {
            'pending': '#9E9E9E',
            'completed': '#4CAF50',
            'current': '#FFC107',
            'skipped': '#FF9800',
            'error': '#F44336'
        };
        return colors[status] || colors.pending;
    }
    
    return { init, drawShape, drawPoints };
})();
```

**field-contour.js**ï¼ˆäº‘å›¾æ˜¾ç¤ºï¼Œ200è¡Œï¼‰
```javascript
const FieldContour = (function() {
    /**
     * äº‘å›¾æ˜¾ç¤ºï¼šåº”åŠ›åœºæ’å€¼ã€è‰²æ ‡ã€ç­‰é«˜çº¿
     */
    
    let canvas, ctx;
    let contourData = null;
    let showPoints = true;
    
    // åˆå§‹åŒ–
    function init() {
        canvas = document.querySelector('#field-contour-canvas');
        ctx = canvas.getContext('2d');
        bindControlPanel();
    }
    
    // ç”Ÿæˆäº‘å›¾
    async function generateContour() {
        const exp_id = StressDetectionUniaxial.getCurrentExperiment().id;
        const method = document.querySelector('#interpolation-method').value;
        const resolution = parseInt(document.querySelector('#grid-density').value);
        
        const response = await pywebview.api.generate_contour(
            exp_id, method, resolution
        );
        
        if (response.success) {
            contourData = response.data;
            drawContour();
            showToast('âœ“ äº‘å›¾å·²ç”Ÿæˆ', 'success');
        }
    }
    
    // ç»˜åˆ¶äº‘å›¾
    function drawContour() {
        if (!contourData) return;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawContourFill();
        drawShapeOutline();
        if (showPoints) drawPointMarkers();
        drawColorBar();
    }
    
    // ç»˜åˆ¶äº‘å›¾å¡«å……
    function drawContourFill() {
        const { xi, yi, zi, mask, colormap } = contourData;
        // ä½¿ç”¨ ImageData ç»˜åˆ¶å½©è‰²ç½‘æ ¼
        const imageData = ctx.createImageData(xi.length, yi.length);
        // åº”ç”¨è‰²å›¾æ˜ å°„...
        ctx.putImageData(imageData, 0, 0);
    }
    
    // ç»˜åˆ¶è‰²æ ‡
    function drawColorBar() {
        const { vmin, vmax, colormap } = contourData;
        // åœ¨å³ä¾§ç»˜åˆ¶è‰²æ ‡æ¡å’Œåˆ»åº¦
    }
    
    // å®æ—¶æ›´æ–°äº‘å›¾
    function updateContourRealtime(newPointData) {
        // å¢é‡æ›´æ–°ï¼Œä¸éœ€è¦é‡æ–°ç”Ÿæˆæ•´ä¸ªäº‘å›¾
        if (contourData) {
            // é‡æ–°æ’å€¼å¹¶ç»˜åˆ¶
            generateContour();
        }
    }
    
    return { init, generateContour, updateContourRealtime };
})();
```

**single-point.js**ï¼ˆå•ç‚¹æ£€æµ‹ - ä¿ç•™ç°æœ‰æ‰€æœ‰åŠŸèƒ½ï¼‰
```javascript
const SinglePoint = (function() {
    // çŠ¶æ€
    let isMonitoring = false;
    let calibrationData = null;
    let baselineWaveform = null;
    let historyData = [];
    
    // ========== ç°æœ‰åŠŸèƒ½å®Œæ•´ä¿ç•™ ==========
    
    // åˆå§‹åŒ–
    function init() {}
    function show() {}
    function hide() {}
    
    // æ ‡å®šåŠ è½½
    async function loadCalibration() {}
    
    // åŸºå‡†æ³¢å½¢
    async function captureBaseline() {}
    
    // æ³¢å½¢ç›‘æ§ï¼ˆè®¢é˜…å®æ—¶é‡‡é›†æ¨¡å—ï¼‰
    async function startMonitoring() {
        // è®¢é˜…å®æ—¶é‡‡é›†æ¨¡å—çš„æ³¢å½¢æ›´æ–°
        RealtimeCapture.è®¢é˜…æ³¢å½¢æ›´æ–°(handleWaveformUpdate);
    }
    
    async function stopMonitoring() {
        // å–æ¶ˆè®¢é˜…
        RealtimeCapture.å–æ¶ˆè®¢é˜…æ³¢å½¢æ›´æ–°(handleWaveformUpdate);
    }
    
    // å¤„ç†æ³¢å½¢æ›´æ–°ï¼ˆè®¢é˜…å›è°ƒï¼‰
    function handleWaveformUpdate(data) {
        // ç»˜åˆ¶æ³¢å½¢
        drawWaveform(data.æ³¢å½¢æ•°æ®, data.æ˜¾ç¤ºçŠ¶æ€);
        
        // å¦‚æœæ­£åœ¨æ£€æµ‹ï¼Œè®¡ç®—åº”åŠ›å€¼
        if (isDetecting) {
            calculateStress(data.æ³¢å½¢æ•°æ®);
        }
    }
    
    // åº”åŠ›æ£€æµ‹
    async function startDetection() {}
    async function stopDetection() {}
    async function calculateStress(waveform) {}
    
    // ç»˜åˆ¶æ³¢å½¢
    function drawWaveform(waveformData, displayState) {
        // ä½¿ç”¨ CommonUtils.ç»˜åˆ¶æ³¢å½¢åˆ°ç”»å¸ƒ()
    }
    
    // è®°å½•å’Œå¯¼å‡º
    function recordCurrentValue() {}
    async function exportHistory() {}
    
    return { 
        init, show, hide, 
        loadCalibration, 
        startMonitoring, stopMonitoring 
    };
})();
```

**field-mapping.js**ï¼ˆåº”åŠ›åœºæµ‹ç»˜ - æ–°å¢åŠŸèƒ½ï¼‰
```javascript
const FieldMapping = (function() {
    // çŠ¶æ€
    let stage = 'planning';  // planning/capturing/analyzing
    let experimentId = null;
    let shapeConfig = null;
    let points = [];
    let currentPointIndex = 0;
    
    // åˆå§‹åŒ–
    function init() {}
    function show() {}
    function hide() {}
    
    // ========== å½¢çŠ¶å®šä¹‰ ==========
    function setShapeType(type) {}  // rectangle/circle/polygon
    function updateShapeParams(params) {}
    function addModifier(modifier) {}  // æ·»åŠ å­”æ´/ç¼ºå£
    function removeModifier(index) {}
    async function validateShape() {}
    function drawShapePreview() {}
    
    // ========== å¸ƒç‚¹è®¾ç½® ==========
    function setLayoutType(type) {}  // grid/polar/adaptive/custom
    async function generatePoints(params) {}
    function addPoint(x, y) {}  // æ‰‹åŠ¨æ·»åŠ 
    function removePoint(id) {}
    async function optimizeOrder(strategy) {}
    function drawPointsPreview() {}
    
    // ========== é‡‡é›†æ§åˆ¶ ==========
    async function startCapture() {}
    async function captureCurrentPoint() {
        // ä»å®æ—¶é‡‡é›†æ¨¡å—è·å–æ³¢å½¢
        const waveform = await RealtimeCapture.è·å–å½“å‰RAWæ³¢å½¢();
        // è®¡ç®—æ—¶é—´å·®å’Œåº”åŠ›å€¼
        // ä¿å­˜æ•°æ®
        // æ›´æ–°äº‘å›¾
    }
    async function skipPoint() {}
    async function retryPoint() {}
    function pauseCapture() {}
    function updateProgress() {}
    
    // ========== äº‘å›¾æ˜¾ç¤º ==========
    async function updateContour() {
        const result = await pywebview.api.update_contour(experimentId);
        ContourDrawing.drawContourMap(canvas, result.data);
    }
    
    // ========== æ•°æ®è¡¨æ ¼ ==========
    function renderTable() {}
    function updateTableRow(pointId, data) {}
    function sortTable(column) {}
    function filterTable(status) {}
    
    // ========== å¯¼å‡º ==========
    async function exportResults(format) {}  // png/csv/excel
    
    return { 
        init, show, hide, 
        startCapture, updateContour 
    };
})();
```

**contour-drawing.js**ï¼ˆäº‘å›¾ç»˜åˆ¶å·¥å…·ï¼‰
```javascript
const ContourDrawing = (function() {
    // ç»˜åˆ¶äº‘å›¾
    function drawContourMap(canvas, contourData, shapeConfig) {
        // ç»˜åˆ¶å¡«å……äº‘å›¾
        // åº”ç”¨é¢œè‰²æ˜ å°„
        // ç»˜åˆ¶å½¢çŠ¶è½®å»“
        // é®ç½©æ— æ•ˆåŒºåŸŸ
    }
    
    // é¢œè‰²æ˜ å°„
    function applyColormap(data, vmin, vmax, cmap) {
        // å½’ä¸€åŒ–
        // åº”ç”¨è‰²å›¾ï¼ˆrainbow/jet/viridisï¼‰
    }
    
    // ç»˜åˆ¶ç­‰å€¼çº¿
    function drawIsolines(canvas, contourData, levels) {}
    
    // ç»˜åˆ¶æµ‹ç‚¹æ ‡è®°
    function drawPointMarkers(canvas, points, currentPointId) {
        points.forEach(point => {
            const status = point.status || 'pending';
            let color, marker;
            
            if (point.id === currentPointId) {
                // å½“å‰ç‚¹ï¼šé»„è‰²é«˜äº®
                color = '#FFC107';
                marker = 'â—';
            } else if (status === 'completed') {
                // å·²æµ‹ç‚¹ï¼šç»¿è‰²å®å¿ƒåœ†
                color = '#4CAF50';
                marker = 'â—';
            } else if (status === 'skipped') {
                // è·³è¿‡ï¼šæ©™è‰²
                color = '#FF9800';
                marker = 'Ã—';
            } else {
                // å¾…æµ‹ç‚¹ï¼šç°è‰²ç©ºå¿ƒåœ†
                color = '#9E9E9E';
                marker = 'â—‹';
            }
            
            // ç»˜åˆ¶æ ‡è®°
            ctx.fillStyle = color;
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(marker, point.x, point.y);
            
            // ç»˜åˆ¶æµ‹ç‚¹ç¼–å·
            ctx.fillStyle = '#212121';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(`#${point.id}`, point.x, point.y - 10);
        });
    }
    
    // ç»˜åˆ¶è‰²æ ‡
    function drawColorbar(canvas, vmin, vmax, cmap) {}
    
    // ç»˜åˆ¶å½¢çŠ¶è½®å»“
    function drawShapeOutline(canvas, shapeConfig) {}
    
    return { 
        drawContourMap, 
        drawIsolines, 
        drawPointMarkers, 
        drawColorbar 
    };
})();
```

---

### 2.3 æ ·å¼æ–‡ä»¶
```
static/css/
â””â”€â”€ stress-detection.css    # ç»Ÿä¸€æ ·å¼ï¼ˆåŒ…å«å•ç‚¹å’Œå¤šç‚¹ï¼‰
```

---

### 2.4 ä»£ç è¿ç§»è¯´æ˜

#### ç°æœ‰ä»£ç å¤„ç†
```
ç°æœ‰æ–‡ä»¶: static/js/stress-detection-uniaxial/stress-detection-uniaxial.js (500è¡Œ)

æ‹†åˆ†ä¸º:
1. stress-detection-uniaxial.js (æ–°ï¼Œ200è¡Œ)
   - æ ‡ç­¾é¡µåˆ‡æ¢é€»è¾‘
   - æ¨¡å—åˆå§‹åŒ–

2. single-point.js (300è¡Œ)
   - å®Œæ•´ä¿ç•™ç°æœ‰çš„å•ç‚¹æ£€æµ‹ä»£ç 
   - åŒ…æ‹¬è®¢é˜…æ³¢å½¢ã€ç»˜åˆ¶ã€è®¡ç®—ã€è®°å½•ç­‰æ‰€æœ‰åŠŸèƒ½

3. field-mapping.js (æ–°å¢ï¼Œ600è¡Œ)
   - å…¨æ–°çš„åº”åŠ›åœºæµ‹ç»˜åŠŸèƒ½

4. contour-drawing.js (æ–°å¢ï¼Œ200è¡Œ)
   - äº‘å›¾ç»˜åˆ¶å·¥å…·å‡½æ•°
```

#### å…³é”®æ¥å£ä¿æŒä¸å˜
- `RealtimeCapture.è®¢é˜…æ³¢å½¢æ›´æ–°()` - å•ç‚¹æ£€æµ‹ç»§ç»­ä½¿ç”¨
- `RealtimeCapture.è·å–å½“å‰RAWæ³¢å½¢()` - åº”åŠ›åœºæµ‹ç»˜é‡‡é›†æ—¶ä½¿ç”¨
- `CommonUtils.ç»˜åˆ¶æ³¢å½¢åˆ°ç”»å¸ƒ()` - ä¸¤ä¸ªåŠŸèƒ½å…±ç”¨

---

### 2.5 æ–‡ä»¶å¤§å°ä¼°ç®—

#### åç«¯
- stress_detection_uniaxial.py: ~600è¡Œ
- shape_utils.py: ~200è¡Œ
- point_generator.py: ~200è¡Œ
- interpolation.py: ~150è¡Œ
- **æ€»è®¡ï¼š~1150è¡Œ**

#### å‰ç«¯
- stress-detection-uniaxial.js: ~200è¡Œ
- single-point.js: ~300è¡Œ
- field-mapping.js: ~600è¡Œ
- contour-drawing.js: ~200è¡Œ
- **æ€»è®¡ï¼š~1300è¡Œ**

---

**ğŸ“„ æ–‡æ¡£è¯´æ˜**ï¼šæœ¬æ–‡æ¡£ä¸ºç¬¬1éƒ¨åˆ†ï¼ŒåŒ…å«ç¬¬1-2ç« å†…å®¹ã€‚  
**â¡ï¸ ä¸‹ä¸€éƒ¨åˆ†**ï¼š[å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬1.5éƒ¨åˆ†.md](./å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬1.5éƒ¨åˆ†.md)ï¼ˆç¬¬3ç«  ç•Œé¢è®¾è®¡ï¼‰
