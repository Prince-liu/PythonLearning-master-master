# å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£ v1.0 - ç¬¬3éƒ¨åˆ†

> **åŒ…å«ç« èŠ‚**ï¼šç¬¬7ç«  å®æ—¶äº‘å›¾ç®—æ³•ã€ç¬¬8ç«  æ•°æ®ç»“æ„  
> **ä¸Šä¸€éƒ¨åˆ†**ï¼š[ç¬¬2éƒ¨åˆ†](./å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬2éƒ¨åˆ†.md)  
> **ä¸‹ä¸€éƒ¨åˆ†**ï¼š[ç¬¬4éƒ¨åˆ†](./å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬4éƒ¨åˆ†.md)

---

## 7. å®æ—¶äº‘å›¾ç®—æ³•

### 7.1 æ¸è¿›å¼æ’å€¼ç­–ç•¥

#### é˜¶æ®µåˆ’åˆ†
```python
def get_interpolation_strategy(n_measured):
    """æ ¹æ®å·²æµ‹ç‚¹æ•°é€‰æ‹©æ’å€¼ç­–ç•¥"""
    if n_measured < 3:
        return 'points_only'  # åªæ˜¾ç¤ºç¦»æ•£ç‚¹
    elif n_measured < 9:
        return 'linear'       # çº¿æ€§æ’å€¼ + è­¦å‘Š
    else:
        return 'cubic'        # ä¸‰æ¬¡æ’å€¼
```

#### å®æ—¶æ›´æ–°é€»è¾‘
```python
async def update_contour_realtime(new_point_data):
    """å®æ—¶æ›´æ–°äº‘å›¾"""
    # 1. æ·»åŠ æ–°æµ‹ç‚¹æ•°æ®
    measured_points.append(new_point_data)
    
    # 2. åˆ¤æ–­æ’å€¼ç­–ç•¥
    strategy = get_interpolation_strategy(len(measured_points))
    
    if strategy == 'points_only':
        # åªç»˜åˆ¶ç¦»æ•£ç‚¹
        draw_discrete_points(measured_points)
        show_message("æ•°æ®ç‚¹ä¸è¶³ï¼Œæš‚ä¸ç”Ÿæˆäº‘å›¾")
        
    elif strategy == 'linear':
        # çº¿æ€§æ’å€¼ + è­¦å‘Š
        contour_data = interpolate_linear(measured_points)
        draw_contour(contour_data, alpha=0.7)  # åŠé€æ˜
        show_warning("æ•°æ®ç‚¹è¾ƒå°‘ï¼Œäº‘å›¾ä»…ä¾›å‚è€ƒ")
        
    else:
        # å®Œæ•´ä¸‰æ¬¡æ’å€¼
        contour_data = interpolate_cubic(measured_points)
        draw_contour(contour_data, alpha=1.0)
```

### 7.2 æ’å€¼ç®—æ³•å®ç°

#### æ ¸å¿ƒä»£ç 
```python
from scipy.interpolate import griddata
import numpy as np

def interpolate_stress_field(points, shape_config, resolution=100):
    """æ’å€¼ç”Ÿæˆåº”åŠ›åœº"""
    # 1. æå–åæ ‡å’Œåº”åŠ›å€¼
    coords = np.array([[p['x'], p['y']] for p in points])
    stress = np.array([p['stress'] for p in points])
    
    # 2. ç”Ÿæˆå¯†é›†ç½‘æ ¼
    x_min, x_max = 0, shape_config['width']
    y_min, y_max = 0, shape_config['height']
    
    xi = np.linspace(x_min, x_max, resolution)
    yi = np.linspace(y_min, y_max, resolution)
    xi, yi = np.meshgrid(xi, yi)
    
    # 3. æ’å€¼è®¡ç®—
    method = 'cubic' if len(points) >= 9 else 'linear'
    zi = griddata(coords, stress, (xi, yi), method=method)
    
    # 4. é®ç½©æ— æ•ˆåŒºåŸŸï¼ˆå­”æ´ã€è¾¹ç•Œå¤–ï¼‰
    mask = create_shape_mask(xi, yi, shape_config)
    zi = np.ma.masked_where(~mask, zi)
    
    return xi, yi, zi
```

#### å½¢çŠ¶é®ç½©ä¸è¾¹è·åŒºåŸŸå¤„ç†

**è®¾è®¡åŸåˆ™**ï¼š
- **åªæ˜¾ç¤ºæœ‰å®æµ‹æ•°æ®çš„åŒºåŸŸ**ï¼ˆæµ‹è¯•åŒºåŸŸï¼‰
- **è¾¹è·åŒºåŸŸä¸æ˜¾ç¤ºäº‘å›¾**ï¼ˆæ— æ•°æ®åŒºåŸŸï¼Œé¿å…å¤–æ¨è¯¯å¯¼ï¼‰
- **æ¸…æ™°åŒºåˆ†**ï¼šç”¨ä¸åŒé¢œè‰²æ ‡è¯†æœ‰æ•°æ®åŒºå’Œæ— æ•°æ®åŒº

**é®ç½©ç±»å‹**ï¼š
1. **å½¢çŠ¶é®ç½©**ï¼šæ’é™¤æ ·ä»¶å¤–éƒ¨ã€å­”æ´ã€ç¼ºå£
2. **è¾¹è·é®ç½©**ï¼šæ’é™¤è¾¹è·åŒºåŸŸï¼ˆæ— æµ‹ç‚¹åŒºåŸŸï¼‰

```python
def create_shape_mask(xi, yi, shape_config, layout_config):
    """åˆ›å»ºå½¢çŠ¶é®ç½©ï¼ˆåŒ…å«è¾¹è·åŒºåŸŸé®ç½©ï¼‰"""
    from shapely.geometry import Point, Polygon, box
    
    # 1. åˆ›å»ºæ ·ä»¶å½¢çŠ¶å¯¹è±¡
    if shape_config['type'] == 'rectangle':
        shape = create_rectangle_shape(shape_config)
    elif shape_config['type'] == 'circle':
        shape = create_circle_shape(shape_config)
    else:
        shape = Polygon(shape_config['vertices'])
    
    # 2. åº”ç”¨å¸ƒå°”è¿ç®—ï¼ˆå‡å»å­”æ´ï¼‰
    for modifier in shape_config['modifiers']:
        if modifier['op'] == 'subtract':
            hole = create_hole_shape(modifier)
            shape = shape.difference(hole)
    
    # 3. åˆ›å»ºæµ‹è¯•åŒºåŸŸï¼ˆæ’é™¤è¾¹è·ï¼‰
    if layout_config['type'] == 'grid':
        margin = layout_config.get('margin', 0)
        test_region = box(
            margin,  # x_min
            margin,  # y_min
            shape_config['width'] - margin,   # x_max
            shape_config['height'] - margin   # y_max
        )
        # æµ‹è¯•åŒºåŸŸ = æ ·ä»¶å½¢çŠ¶ âˆ© æµ‹è¯•åŒºåŸŸ
        valid_region = shape.intersection(test_region)
    else:
        # å…¶ä»–å¸ƒç‚¹æ–¹å¼ï¼šä½¿ç”¨æ ·ä»¶å½¢çŠ¶ä½œä¸ºæœ‰æ•ˆåŒºåŸŸ
        valid_region = shape
    
    # 4. ç”Ÿæˆé®ç½©
    mask = np.zeros_like(xi, dtype=bool)
    for i in range(xi.shape[0]):
        for j in range(xi.shape[1]):
            point = Point(xi[i,j], yi[i,j])
            mask[i,j] = valid_region.contains(point)
    
    return mask
```

**è§†è§‰æ•ˆæœç¤ºä¾‹**ï¼š

```
æ ·ä»¶ 100Ã—150mmï¼Œè¾¹è· 10mmï¼Œæµ‹è¯•åŒºåŸŸ 80Ã—130mm

äº‘å›¾æ˜¾ç¤ºï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚ â† è¾¹è·åŒºï¼šæµ…ç°è‰²/ç™½è‰²
â”‚â–‘â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â–‘â”‚   (æ— æ•°æ®ï¼Œä¸æ˜¾ç¤ºäº‘å›¾)
â”‚â–‘â”‚ğŸ”´ğŸŸ ğŸŸ¡ğŸŸ¢ğŸ”µğŸŸ¢ğŸŸ¡ğŸŸ ğŸ”´      â”‚â–‘â”‚
â”‚â–‘â”‚ğŸŸ ğŸŸ¡ğŸŸ¢ğŸ”µğŸŸ¢ğŸ”µğŸŸ¢ğŸŸ¡ğŸŸ       â”‚â–‘â”‚
â”‚â–‘â”‚ğŸŸ¡ğŸŸ¢ğŸ”µğŸŸ¢ğŸŸ¡ğŸŸ¢ğŸ”µğŸŸ¢ğŸŸ¡      â”‚â–‘â”‚ â† æµ‹è¯•åŒºï¼šå½©è‰²äº‘å›¾
â”‚â–‘â”‚ğŸŸ¢ğŸ”µğŸŸ¢ğŸŸ¡ğŸŸ ğŸŸ¡ğŸŸ¢ğŸ”µğŸŸ¢      â”‚â–‘â”‚   (æœ‰å®æµ‹æ•°æ®)
â”‚â–‘â”‚ğŸ”µğŸŸ¢ğŸŸ¡ğŸŸ ğŸ”´ğŸŸ ğŸŸ¡ğŸŸ¢ğŸ”µ      â”‚â–‘â”‚
â”‚â–‘â”‚ğŸŸ¢ğŸŸ¡ğŸŸ ğŸ”´ğŸŸ ğŸ”´ğŸŸ ğŸŸ¡ğŸŸ¢      â”‚â–‘â”‚
â”‚â–‘â”‚ğŸŸ¡ğŸŸ ğŸ”´ğŸŸ ğŸŸ¡ğŸŸ ğŸ”´ğŸŸ ğŸŸ¡      â”‚â–‘â”‚
â”‚â–‘â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â–‘â”‚
â”‚â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚ â† è¾¹è·åŒºï¼šæµ…ç°è‰²/ç™½è‰²
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è¯´æ˜ï¼š
- å½©è‰²åŒºåŸŸï¼šæœ‰å®æµ‹æ•°æ®çš„æµ‹è¯•åŒºåŸŸ
- ç°è‰²åŒºåŸŸï¼šè¾¹è·åŒºåŸŸï¼ˆæ— æµ‹ç‚¹ï¼Œä¸æ’å€¼ï¼‰
- è™šçº¿æ¡†ï¼šæ ‡æ³¨æµ‹è¯•åŒºåŸŸè¾¹ç•Œï¼ˆå¯é€‰ï¼‰
```

**ç§‘å­¦æ€§è¯´æ˜**ï¼š
- âœ… **ä¸åšæ— æ ¹æ®çš„å¤–æ¨**ï¼šè¾¹è·åŒºåŸŸæ²¡æœ‰æµ‹ç‚¹ï¼Œä¸æ˜¾ç¤ºæ’å€¼ç»“æœ
- âœ… **æ¸…æ™°æ ‡è¯†**ï¼šç”¨æˆ·ä¸€çœ¼çœ‹å‡ºå“ªäº›åŒºåŸŸæœ‰æ•°æ®ï¼Œå“ªäº›æ²¡æœ‰
- âœ… **é¿å…è¯¯å¯¼**ï¼šé˜²æ­¢ç”¨æˆ·è¯¯ä»¥ä¸ºè¾¹è·åŒºåŸŸçš„åº”åŠ›å€¼æ˜¯çœŸå®æµ‹é‡çš„

**å®ç°ç»†èŠ‚**ï¼š
```python
# åº”ç”¨é®ç½©åçš„æ’å€¼ç»“æœ
zi_masked = np.ma.masked_where(~mask, zi)

# Canvas ç»˜åˆ¶æ—¶
# - é®ç½©åŒºåŸŸï¼šå¡«å……æµ…ç°è‰² #F5F5F5 æˆ–ç™½è‰²
# - æœ‰æ•ˆåŒºåŸŸï¼šç»˜åˆ¶å½©è‰²äº‘å›¾
# - è¾¹ç•Œçº¿ï¼šç”¨è™šçº¿æ ‡æ³¨æµ‹è¯•åŒºåŸŸè¾¹ç•Œï¼ˆå¯é€‰ï¼‰
```

### 7.3 æ€§èƒ½ä¼˜åŒ–

#### å¢é‡æ›´æ–°
```python
class ContourCache:
    """äº‘å›¾ç¼“å­˜ï¼Œæ”¯æŒå¢é‡æ›´æ–°"""
    def __init__(self):
        self.last_grid = None
        self.last_points = []
    
    def update(self, new_point):
        """å¢é‡æ›´æ–°äº‘å›¾"""
        # åªé‡æ–°æ’å€¼å—å½±å“çš„åŒºåŸŸ
        affected_region = self.get_affected_region(new_point)
        self.update_region(affected_region, new_point)
```

#### åˆ†è¾¨ç‡è‡ªé€‚åº”
```python
def get_adaptive_resolution(n_points, stage):
    """æ ¹æ®æµ‹ç‚¹æ•°å’Œé˜¶æ®µé€‰æ‹©åˆ†è¾¨ç‡"""
    if stage == 'measuring':
        # é‡‡é›†é˜¶æ®µï¼šä½åˆ†è¾¨ç‡ï¼Œå¿«é€Ÿæ›´æ–°
        return min(50, n_points * 5)
    else:
        # åˆ†æé˜¶æ®µï¼šé«˜åˆ†è¾¨ç‡ï¼Œç²¾ç»†æ˜¾ç¤º
        return 200
```

### 7.4 è§†è§‰æ•ˆæœ

#### é¢œè‰²æ˜ å°„
```python
import matplotlib.cm as cm

def apply_colormap(stress_data, vmin=None, vmax=None, cmap='rainbow'):
    """åº”ç”¨é¢œè‰²æ˜ å°„"""
    if vmin is None:
        vmin = np.nanmin(stress_data)
    if vmax is None:
        vmax = np.nanmax(stress_data)
    
    # å½’ä¸€åŒ–
    norm = (stress_data - vmin) / (vmax - vmin)
    
    # åº”ç”¨è‰²å›¾
    colormap = cm.get_cmap(cmap)
    rgba = colormap(norm)
    
    return rgba
```

#### ç­‰å€¼çº¿å åŠ 
```python
def draw_contour_with_isolines(xi, yi, zi, levels=10):
    """ç»˜åˆ¶äº‘å›¾ + ç­‰å€¼çº¿"""
    # å¡«å……äº‘å›¾
    contourf(xi, yi, zi, levels=100, cmap='rainbow')
    
    # å åŠ ç­‰å€¼çº¿
    contour(xi, yi, zi, levels=levels, colors='black', 
            linewidths=0.5, alpha=0.5)
    
    # æ ‡æ³¨ç­‰å€¼çº¿æ•°å€¼
    clabel(contour_lines, inline=True, fontsize=8)
```

#### æµ‹ç‚¹æ ‡è®°
```python
def draw_point_markers(points, current_point_id=None):
    """ç»˜åˆ¶æµ‹ç‚¹æ ‡è®°"""
    for point in points:
        if point['status'] == 'measured':
            color = 'green'
            marker = 'â—'
        elif point['id'] == current_point_id:
            color = 'yellow'
            marker = 'â—‰'  # é«˜äº®å½“å‰ç‚¹
        else:
            color = 'gray'
            marker = 'â—‹'
        
        draw_marker(point['x'], point['y'], marker, color)
        draw_text(point['x'], point['y'], f"#{point['id']}")
```

---

## 8. æ•°æ®ç»“æ„

### 8.1 æ•°æ®åº“è¡¨è®¾è®¡ï¼ˆSQLiteï¼‰

#### è¡¨1ï¼šfield_experimentsï¼ˆåº”åŠ›åœºå®éªŒï¼‰
```sql
CREATE TABLE field_experiments (
    id TEXT PRIMARY KEY,              -- å®éªŒIDï¼Œå¦‚ "FIELD001"
    name TEXT NOT NULL,               -- å®éªŒåç§°
    calibration_exp_id TEXT NOT NULL, -- å…³è”çš„æ ‡å®šå®éªŒID
    calibration_direction TEXT,       -- æ ‡å®šæ–¹å‘ï¼ˆå¦‚ "0Â°"ï¼‰
    shape_config TEXT NOT NULL,       -- å½¢çŠ¶é…ç½®ï¼ˆJSONï¼‰
    point_layout TEXT NOT NULL,       -- æµ‹ç‚¹å¸ƒå±€ï¼ˆJSONï¼‰
    baseline_point_id INTEGER,        -- åŸºå‡†æµ‹ç‚¹ID
    baseline_stress REAL,             -- åŸºå‡†åº”åŠ›å€¼ï¼ˆå¯é€‰ï¼‰
    status TEXT DEFAULT 'planning',   -- å®éªŒçŠ¶æ€
    created_at TEXT,                  -- åˆ›å»ºæ—¶é—´
    completed_at TEXT,                -- å®Œæˆæ—¶é—´
    notes TEXT                        -- å¤‡æ³¨
);
```

#### è¡¨2ï¼šfield_pointsï¼ˆæµ‹ç‚¹æ•°æ®ï¼‰
```sql
CREATE TABLE field_points (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    experiment_id TEXT NOT NULL,      -- æ‰€å±å®éªŒID
    point_index INTEGER NOT NULL,     -- æµ‹ç‚¹ç¼–å·
    x_coord REAL NOT NULL,            -- Xåæ ‡ (mm)
    y_coord REAL NOT NULL,            -- Yåæ ‡ (mm)
    time_diff REAL,                   -- å£°æ—¶å·® (ns)
    stress_value REAL,                -- åº”åŠ›å€¼ (MPa)
    status TEXT DEFAULT 'pending',    -- æµ‹ç‚¹çŠ¶æ€
    measured_at TEXT,                 -- æµ‹é‡æ—¶é—´
    waveform_file TEXT,               -- HDF5æ–‡ä»¶è·¯å¾„
    quality_score REAL,               -- ä¿¡å·è´¨é‡è¯„åˆ†
    is_suspicious BOOLEAN DEFAULT 0,  -- æ˜¯å¦å¯ç–‘æ•°æ®
    FOREIGN KEY (experiment_id) REFERENCES field_experiments(id)
);

CREATE INDEX idx_field_points_exp ON field_points(experiment_id);
```

#### è¡¨3ï¼šfield_metadataï¼ˆäº‘å›¾å…ƒæ•°æ®ï¼‰
```sql
CREATE TABLE field_metadata (
    experiment_id TEXT PRIMARY KEY,
    interpolation_method TEXT,        -- æ’å€¼æ–¹æ³•
    grid_resolution INTEGER,          -- ç½‘æ ¼åˆ†è¾¨ç‡
    colormap TEXT,                    -- è‰²å›¾åç§°
    vmin REAL,                        -- è‰²æ ‡æœ€å°å€¼
    vmax REAL,                        -- è‰²æ ‡æœ€å¤§å€¼
    contour_image_path TEXT,          -- äº‘å›¾å›¾ç‰‡è·¯å¾„
    statistics TEXT,                  -- ç»Ÿè®¡ä¿¡æ¯ï¼ˆJSONï¼‰
    FOREIGN KEY (experiment_id) REFERENCES field_experiments(id)
);
```

### 8.2 HDF5 æ–‡ä»¶ç»„ç»‡

#### æ–‡ä»¶ç»“æ„
```
data/uniaxial_field/FIELD001/
â”œâ”€â”€ metadata.json              # å®éªŒå…ƒæ•°æ®
â”œâ”€â”€ shape_config.json          # å½¢çŠ¶é…ç½®
â”œâ”€â”€ point_layout.json          # æµ‹ç‚¹å¸ƒå±€
â”œâ”€â”€ point_001.h5               # æµ‹ç‚¹1æ³¢å½¢
â”œâ”€â”€ point_002.h5               # æµ‹ç‚¹2æ³¢å½¢
â”œâ”€â”€ ...
â”œâ”€â”€ point_025.h5               # æµ‹ç‚¹25æ³¢å½¢
â””â”€â”€ contour_result.h5          # äº‘å›¾ç»“æœæ•°æ®
```

#### å•ä¸ªæµ‹ç‚¹HDF5ç»“æ„
```python
# point_001.h5
{
    'waveform': {
        'time': [array],      # æ—¶é—´è½´
        'voltage': [array],   # ç”µå‹å€¼
        'sample_rate': float  # é‡‡æ ·ç‡
    },
    'metadata': {
        'point_id': 1,
        'x_coord': 10.0,
        'y_coord': 10.0,
        'measured_at': '2025-12-19 14:30:15',
        'scope_settings': {...}
    },
    'analysis': {
        'time_diff': 45.23,
        'stress': 120.5,
        'snr': 25.3,
        'quality_score': 0.95
    }
}
```

#### äº‘å›¾ç»“æœHDF5ç»“æ„
```python
# contour_result.h5
{
    'grid': {
        'xi': [2D array],     # Xç½‘æ ¼
        'yi': [2D array],     # Yç½‘æ ¼
        'zi': [2D array]      # åº”åŠ›å€¼ç½‘æ ¼
    },
    'points': {
        'coords': [NÃ—2 array],   # æµ‹ç‚¹åæ ‡
        'stress': [N array]      # æµ‹ç‚¹åº”åŠ›å€¼
    },
    'metadata': {
        'interpolation_method': 'cubic',
        'resolution': 200,
        'n_points': 25,
        'timestamp': '2025-12-19 15:45:30'
    }
}
```

### 8.3 å‰ç«¯æ•°æ®æ ¼å¼

#### å½¢çŠ¶é…ç½®å¯¹è±¡
```javascript
const shapeConfig = {
    type: 'rectangle',  // 'rectangle' | 'circle' | 'polygon'
    
    // çŸ©å½¢å‚æ•°
    width: 100,
    height: 150,
    
    // åœ†å½¢å‚æ•°
    centerX: 50,
    centerY: 50,
    outerRadius: 40,
    innerRadius: 0,
    startAngle: 0,
    endAngle: 360,
    
    // å¤šè¾¹å½¢å‚æ•°
    vertices: [[0,0], [100,0], [100,100], [0,100]],
    
    // å¸ƒå°”è¿ç®—
    modifiers: [
        {
            op: 'subtract',  // 'subtract' | 'add'
            shape: 'circle',
            centerX: 50,
            centerY: 75,
            radius: 20
        }
    ]
};
```

#### æµ‹ç‚¹æ•°æ®å¯¹è±¡
```javascript
const pointData = {
    id: 1,
    x: 10.0,
    y: 10.0,
    timeDiff: 45.23,
    stress: 120.5,
    status: 'measured',  // 'pending' | 'measuring' | 'measured' | 'skipped' | 'error'
    measuredAt: '2025-12-19 14:30:15',
    qualityScore: 0.95,
    isSuspicious: false
};
```

#### äº‘å›¾æ•°æ®å¯¹è±¡
```javascript
const contourData = {
    grid: {
        xi: [[...]],  // 2D array
        yi: [[...]],
        zi: [[...]]   // åº”åŠ›å€¼
    },
    points: [
        {id: 1, x: 10, y: 10, stress: 120.5},
        // ...
    ],
    metadata: {
        method: 'cubic',
        resolution: 200,
        vmin: 0,
        vmax: 200,
        confidence: 'full'  // 'preview' | 'full'
    }
};
```

---

**ğŸ“„ æ–‡æ¡£è¯´æ˜**ï¼šæœ¬æ–‡æ¡£ä¸ºç¬¬3éƒ¨åˆ†ï¼ŒåŒ…å«ç¬¬7-8ç« å†…å®¹ã€‚  
**â¬…ï¸ ä¸Šä¸€éƒ¨åˆ†**ï¼š[å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬2éƒ¨åˆ†.md](./å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬2éƒ¨åˆ†.md)  
**â¡ï¸ ä¸‹ä¸€éƒ¨åˆ†**ï¼š[å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬4éƒ¨åˆ†.md](./å•è½´åº”åŠ›æ£€æµ‹æ¨¡å—è®¾è®¡æ–‡æ¡£-ç¬¬4éƒ¨åˆ†.md)
